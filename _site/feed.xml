<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2025-01-05T01:53:19+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">JSC’s DevLog</title><subtitle>SE and AI version 1.0</subtitle><author><name>JSC</name><email>newwin0198@handong.ac.kr</email></author><entry><title type="html">한동에서의 마지막 2학기를 돌아보며 Part 1</title><link href="http://localhost:4000/recent/7,8th_Semester_Recap_Part1/" rel="alternate" type="text/html" title="한동에서의 마지막 2학기를 돌아보며 Part 1" /><published>2025-01-03T00:00:00+09:00</published><updated>2025-01-03T00:00:00+09:00</updated><id>http://localhost:4000/recent/7,8th_Semester_Recap_Part1</id><content type="html" xml:base="http://localhost:4000/recent/7,8th_Semester_Recap_Part1/"><![CDATA[<p>마지막 블로그 글을 쓴지 1년이 지나버렸다…</p>

<p>계속 써야지, 써야지 했지만 이제야 와서 쓰다니. 이렇게 늦어질지 몰랐다. ㅎㅎ
1년만에 글을 쓰는 만큼 많은 일이 있었고, 많은 변화가 있었다.</p>

<p>나만 그렇게 느낀 것이 아니였는지, 지금까지 살면서 <strong>달라졌다</strong> 라는 말을 가장 많이 들은 1년이 아닌가 싶다.</p>

<p>지난 1년간 있었던 가장 큰 일들을 꼽자면 다음과 같다:</p>

<ol>
  <li>
    <p>오석교회 출석</p>
  </li>
  <li>
    <p>KCC 2024 논문 작성 및 일반 논문 우수상 수상</p>
  </li>
  <li>
    <p>대학원 입시 준비</p>
  </li>
  <li>
    <p>캄보디아 선교</p>
  </li>
  <li>
    <p>국제학술 대회 논문 투고</p>
  </li>
  <li>
    <p><del>T1 월즈 우승 및 Faker Final MVP 수상</del></p>
  </li>
</ol>

<p>천천히 하나씩 짚어보자.</p>

<hr />

<h4 id="1오석교회-출석">1.오석교회 출석</h4>

<p>한동에서 만난 교수님들 중 내가 존경하는 교수님 두 분이 한동에서 기회가 있을 때 신앙 공동체에 소속되어 보고 <strong>신앙 훈련</strong>을 경험해보라는 조언을 해주셨었다. 두 분께서 2학년과 3학년 각 학기마다 적어도 한 번씩은 해주셨기에 항상 마음에 담아두고 있던 조언이었다.</p>

<p>나도 조언을 계속 담아두고 있었음은 나도 나의 <em>신앙생활의 잘못됨</em>을 느꼈기 때문이지 않을까 라는 생각이 든다. 모태신앙으로 태어나보니 교회를 다니고 있었다. 하나님의 존재를 딱히 부정하지는 않지만, 그렇다고 깊은 고민을 해본 적은 없다. 초등학교 6학년부터 고등학교 3학년까지, 타의가 섞여있었던 7년간의 기독대안학교에서의 신앙생활(새벽, 수요, 금요예배가 모두 필수였다)은 나를 지치게 했다. <del>물론 운이 좋아 새벽예배는 모두 피하긴 했다. 아직도 친구들에게 미안한 감정이 있다.</del></p>

<p>대학교에 와서 맛본 자유는 매우 달았다. 교회를 빠진 적은 없지만, 그냥 주일에 학교 채플에 가서 예배를 드렸다. 나의 시간이 너무 소중했고 봉사나 교제가 없는 신앙생활이 너무 편했다.</p>

<p>어느 순간 나에게 이런 생각이 들었다. “한동에서도 이렇게 신앙 생활하면 밖에서는 어떻게 신앙생활 하지?” 아무리 한동에 다양한 사람이 있다고 하지만 사회에 비하면 기독교인의 비율은 굉장히 높은 편이다. 그리고 한동의 이점은 나와 비슷한 나이를 가지고, 비슷한 고민을 하는 친구들이 있는 신앙 공동체가 많다는 것 아닌가!</p>

<p>이러한 생각을 바탕으로 외부교회를 찾기 시작했고, 먼저 <del>(내 친구가 처음보고 18학번으로 오해한)</del> 캡스톤 파트너가 몸담고 있었던 오석교회를 나가게 되었다. 오석교회는 신앙 공동체인 오석공동체가 설립한 교회로, 내가 존경하는 교수님 JC의 은사님이시자 한동대학교 전산전자공학부 명예교수, 부총장을 지니신 김영섭 목수(목사/교수)가 섬기시고 있는 공동체이다. 수업을 들어본 적은 없지만, 목수님의 이야기를 많이 접해 내적친밀감이 쌓여있던 상태였다.</p>

<p>첫번째 예배를 참석한 후, 큰 고민없이 오석 교회에 출석하기로 했다. 말씀이 굉장히 논리적이었고, 신앙공동체를 기반에 두고 있다보니 모든 교인이 청년일 뿐만 아니라 같은 전공을 공부하는 선배, 친구, 후배들이 있어 편안했다.</p>

<p>2024년도를 시작하면서 내린 첫 번째 중요한 결정이었고, 이 결정이 2024년을 완전히 바꾸었으며 나의 추후의 삶을 더더욱 변화시키길 바란다. 자세한 변화의 이야기는 추후에 캄보디아 선교 부분에서 다룰 것이다.</p>

<p><em>So whether you eat or drink or whatever you do, do it all for the glory of God – 1 Corinthians 10:31</em></p>

<hr />

<h4 id="2-kcc-2024-논문-작성-및-일반-논문-우수상-수상">2. KCC 2024 논문 작성 및 일반 논문 우수상 수상</h4>

<p>어느새 ISEL에서 학부생 인턴을 한지 3학기 째가 되었다. 아무것도 몰랐을 때 받았던 주제인 자동 프로그램 수정 기법, 지난 2학기 동안은 논문 리뷰의 연속이었다. 자동 프로그램 수정 기법 자체가 다양한 기법들의 조합으로 이루어지기에 해당 기법들을 공부하는데 꽤 많은 시간을 쏟았다. 
<del>물론 지금 완전히 이해하고 있냐고 하면 자신있게 대답은 못하겠다.</del></p>

<p>2학기의 학부생 인턴 경험을 거치고 어느새 캡스톤 프로젝트를 진행하는 학기가 되었다. 가시적인 성과가 필요했기에 그만큼 부담이 있던 것도 사실이었다. 이게 과연 학부생 수준에서 할 수 있는 연구가 맞을까 라는 고민이 나를 사로잡기도 했다. 
그럼에도 교수님께서는 멈추지 않으셨고 당근과 채찍으로 나를 잘 인도해주셨다.</p>

<p>한동대학교에서 컴퓨터공학심화을 전공하는 학생들은 졸업을 위해 논문 출판, 특허 신청, 그리고 소프트웨어 출시, 이 셋 중에서 한가지를 경험해야 한다. ISEL에서는 보통 KCSE, 한국 소프트웨어 공학학술대회에 논문을 제출하여 졸업요건을 채운다. 
나도 자연스럽게 KCSE에 논문을 제출하여 졸업요건을 채울 줄 알았것만… KCSE 2024에서 지도 교수님께서 학술위원장을 맡으셔서 논문 제출을 못하게 되었다.</p>

<p>티는 안냈지만 불안했다. 논문을 어디에 제출하지? 대학원 준비 해야하는데, 논문 성과 없이 대학원 지원해도 괜찮으려나? 다양한 질문이 내 머릿속에 맴돌았다.</p>

<p>캡스톤 프로젝트를 팀원들과 열심을 다해 진행했고 대학원 입시 전에 KCC, 한국컴퓨터종합학술대회가 열려 이곳에 논문을 제출하기로 했다. 이를 목표로 열심히 데이터도 만들고 분석도 해서 갔다.</p>

<p>교수님께서는 결과를 보시고 다음과 같이 말씀하셨다.</p>

<blockquote>
  <p>결과가 꽤 괜찮은데, 학부생 논문말고 일반논문으로 내보죠?</p>
</blockquote>

<p>일반 논문이어도 3~4장의 분량이다. 구두 발표를 해야하긴 하지만 오히려 좋은 경험이 될텐데, 지금 생각해보면 왜 그렇게 생각이 많아졌는지 모르겠다. 
교수님이 시키면 해야지. 아무래도 한국어 논문이다 보니 영어 논문 작성보다는 겁이 덜 났고, 든든한 팀원들과 서로의 부족한 면을 채워주며 논문을 작성했다.</p>

<p>마감일을 하루 남기고 논문을 퇴고하고 있는 나를 보며 하신 교수님의 말씀은 아직도 생생하다.</p>

<blockquote>
  <p>봐도봐도 고칠게 나오죠?</p>
</blockquote>

<p>논문을 열심히 작성해 투고했고, 결과를 기다리고 있었다. 어느 금요일, 오석공동체 기도회가 있어 앞서 말한 18학번으로 오해받은 친구와 길을 가던 중 다음과 같은 메일을 받았다.</p>

<p><img src="../../../assets/7,8semRecap/AwardEmail.png" width="700" height="170" /></p>

<p>꽤나 놀랐다. 교수님께서도 자랑스러우셨는지 담당하는 수업 톡방에 다음과 같이 글을 올리시기도 했다.</p>

<p align="center">
<img src="../../../assets/7,8semRecap/JC_Kakao.jpg" width="400" />
</p>

<p>국제 학술대회가 아닌 국내 학술대회에서 상을 받았다는 것에 글을 올리는 것이 우스워 보일지 모르겠지만, 그래도 첫 논문이 상을 받는 영광을 누릴 수 있어서 기뻤다.</p>

<p>생각해보면 교수님은 랩미팅 도중에 이런 말도 하셨다.</p>

<blockquote>
  <p>아 맞다. 일반논문으로 우수논문상 받으면 정보과학회 학술지에 초청논문으로 투고할 수 있어요. 열심히 해봐요 ㅎㅎ</p>
</blockquote>

<p>어디까지 보신걸까…</p>

<p>아무튼, 이후에는 제주도로 팀원들과 가서 구두 발표를 진행했고 그 다음날에는 시상식에도 참여했다. <del>호텔은 너무 좋았고 고등어회는 맛있었으며 갈치조림은 진짜 맛있었다</del> 지나가다가 홍참길 교수님께서 나를 알아보시고 <del>(어떻게 알아보신거지)</del> 축하도 해주시고 사진도 찍어주셨다. UNIST 진학한 연구실 선배도 만났다. 연구실 선배가 밥도 사줬다.</p>

<p align="center">
<img src="../../../assets/7,8semRecap/KCC_Award.jpg" width="60%" />
</p>

<p>지금까지 불안함은 내가 열심을 다하는 원동력이 되어줬다. 그 뿐이었다.</p>

<p>캡스톤 프로젝트를 진행하며 여러 어려움과 예상치 못한 상황이 있었다. 불안함이 있었다. 그럼에도 그 전만큼 흔들리지 않았던 것은 가장 좋은 길로 나를 이끄시는 하나님을 믿기 시작했기 때문이다.</p>

<p><em>사람이 마음으로 자기의 길을 계획할지라도 그의 걸음을 인도하시는 이는 여호와시니라 - 잠언 16:9</em></p>]]></content><author><name>JSC</name><email>newwin0198@handong.ac.kr</email></author><category term="Blog" /><category term="Blog" /><summary type="html"><![CDATA[7 and 8th Semster Recap Part 1]]></summary></entry><entry><title type="html">6학기를 돌아보며</title><link href="http://localhost:4000/recent/6th_Semester_Recap/" rel="alternate" type="text/html" title="6학기를 돌아보며" /><published>2024-01-28T00:00:00+09:00</published><updated>2024-01-28T00:00:00+09:00</updated><id>http://localhost:4000/recent/6th_Semester_Recap</id><content type="html" xml:base="http://localhost:4000/recent/6th_Semester_Recap/"><![CDATA[<p>6학기가 마친지 벌써 4주 정도가 지났다. 시간이 참 빠르다…</p>

<p><a href="../../../recent/6th-Semester">6학기를 앞두고 5학기를 돌아보며!</a>라는 글을 쓴지 얼마 되지 않은 것 같은데, 6학기가 벌써 끝나다니…</p>

<p>6학기는 저번 학기에 비해 수월했다.</p>

<p>TA 업무는 적응이 되어 속도가 붙었고, 수강생들을 대하는 것도 편해졌다. <br />
저번 학기에 OS, DB, 알고 3과목이 있었다면 이번학기는 ML, PLT, 컴퓨터 네트워크 3과목이 있었다. 마음 가짐의 변화인지, 같이 듣는 교양 과목들이 편해서 그랬는지 모르겠지만 “편안하게” 수업을 들을 수 있었다.</p>

<p>“편안함”에 Quotation이 붙었다. (<del>이번학기 최고의 수확은 <프렌즈>일지도)</프렌즈></del></p>

<p><img src="../../../assets/Joey_Quotation.jpg" width="700" height="170" /></p>

<p>이번 학기가 마냥 편안했다는 건 아니다. 당장 3과목을 놓고 비교한다면, 종합적인 과목의 난이도는 이번 학기가 높았다.</p>

<p>특히 ML, Machine Learning은 수학 증명을 따라가느라 많은 시간을 보냈다. (아직도 공부하는 중이다.)
이외에도 PLT, Programming Language Theory는 컴퓨터 공학과에서 열리는 수업들 중 손에 꼽을 난이도를 가진 수업이고, 컴퓨터 네트워크는 수업 담당 교수님의 특성상 외워야 하는 분량이 꽤 많았다.</p>

<p><strong>이러한 차이가 나온 이유를 생각해보면, 이번 학기는 참 건강하게 보냈지 싶다.</strong></p>

<p>앞선 학기, 5학기는 나에게 가장 힘들었던, 눈코 뜰 새도 없이 바쁜 학기였지만, 나는 많은 걸 깨달았다. 공부는 체력 싸움이라는 말을 처음으로 이해했고 쉼의 중요성을 알았다.</p>

<p>체력을 위해 방학부터 꾸준히 운동을 했고, 학기 중에도 중간과 기말기간 외에는 주 5일 이상 운동했다. 방학 때도 꾸준히 하고 있다. 
운동을 하며 취미가 자연스럽게 생겼다. 내가 봐도 참 건강하다. 좋다.</p>

<p>학기 중 “멘탈” 강화에 대한 노력도 높이 사고 싶다.</p>

<p>정확히 나는 멘탈이 약하다기 보다는 “나의 의지에 반하는 변화”에 대해 극도로 예민하다. 
랩실에 공공연히 퍼진 이야기인데, 내 머리가 헝클어져 있다면 나에게 무슨 일이 생긴거라나…</p>

<p>일이 술술 풀린다면 높은 성과를 내지만 조그마한 “변화” 때문에 미끄러지는 경우가 많다. 너무나도 작은 변화에 예민하다. 훌훌털면 좋을텐데. <br />
상담도 받아보고 여러 책도 읽어봤는데, 나에게 엄격한 부분, 그리고 취미와 이야기를 나눌 친구가 없음을 지적받았다.</p>

<p>운동은 훌륭한 취미가 되어주었고, 여자친구와 통화 횟수를 늘렸다.</p>

<p>더 나아가 나에게 엄격한 부분에 대해, <strong>타인이 나를 바라보는 것에 너무 예민하다</strong> 는 점을 지적받았다.
남에 대한 이해가 부족하다는 점도 지적받았다. 나를 찾기 위해, 또 사람들의 다양한 인생을 공부하기 위해 노력 중이다.</p>

<p>물론 공부도 열심히 했다.</p>

<p>부끄럽지만 이번 학기 수강한 모든 과목에서 A+을 성취해냈고 졸업 프로젝트도 실마리가 보이고 있다. <del>(교수님이 굉장히 즐거워하신다.)</del></p>

<p>너무 감사한 학기다. <strong>그리고 T1이 롤드컵 우승했다. 너무 행복하다.</strong></p>

<p>다음 학기도 계속 노력해보고자 한다. 이제 대학원 준비를 진지하게 시작해야 할 시기이다. 다음 학기도 좋은 성과를 이루어 냈으면 하고, 이번 학기처럼 후회없는 학기가 되었으면 좋겠다.</p>

<hr />

<p><em>내가 궁핍하므로 말하는 것이 아니니라 어떠한 형편에든지 나는 자족하기를 배웠노니, 나는 비천에 처할 줄도 알고 풍부에 처할 줄도 알아 모든 일 곧 배부름과 배고픔과 풍부와 궁핍에도 처할 줄 아는 일체의 비결을 배웠노라 내게 능력 주시는 자 안에서 내가 모든 것을 할 수 있느니라 (빌립보서 4장 11 ~ 13절)</em></p>]]></content><author><name>JSC</name><email>newwin0198@handong.ac.kr</email></author><category term="Blog" /><category term="Blog" /><summary type="html"><![CDATA[6th Semster Recap]]></summary></entry><entry><title type="html">6학기를 앞두고 5학기를 돌아보며!</title><link href="http://localhost:4000/recent/6th-Semester/" rel="alternate" type="text/html" title="6학기를 앞두고 5학기를 돌아보며!" /><published>2023-08-26T00:00:00+09:00</published><updated>2023-08-26T00:00:00+09:00</updated><id>http://localhost:4000/recent/6th-Semester</id><content type="html" xml:base="http://localhost:4000/recent/6th-Semester/"><![CDATA[<p>정말로 바빴던 방학을 마무리하고 한동에서의 6학기를 앞두고 있다!<br /></p>

<p>저번 학기 Recap을 써야지 써야지 하면서 결국 마무리하지 못했다. 6학기 시작 글과 Recap을 잘 버무려서 써보면 좋겠다는 생각에 글을 쓰고 있다!<br />5학기는 정말 힘든 학기였다. 내가 한동에 다니면서 이렇게까지 힘들고 지친적이 있었나 라는 질문을 스스로 던졌던 학기였다. 다들 5학기가 힘들다 힘들다 하지만 이 정도로 힘들 줄은 ㅠㅠ… <br /></p>

<p>그래도 많이 배운 학기였다. 저번 학기에 이룬 점이라고 한다면…</p>

<ul>
  <li>학기 중에 토익을 봤고 나쁘지 않은 성적을 받았다! (공부 한 번도 안하고 900 넘겼으니 잘한 거 아닐까…? <del>우리학교 사람들 너무 영어 잘해 ㅠㅠ</del>)</li>
  <li>국가이공계우수장학생에 선정되어서 남은 2년 동안 전액 장학금을 받는다!</li>
  <li>TA로 섬기게 되었고 우수 TA 상도 받았다!</li>
  <li>그 어렵다는 홍신 교수님 OS 좋은 성적 받았다! <del>(솔직히 말이 안되는 성적을 받았다)</del></li>
</ul>

<p>물론 가장 아쉬운 학기였다는 건 부정할 수 없을 것 같다. 학부에 들어온 후 가장 낮은 성적을 받았고 가장 멘탈적으로 힘든 학기였다. 처음으로 지친다는 것을 경험해보기도 했고, 무엇보다 팀플이 가장 힘들었다… 학부 내에서 좋은 인맥을 쌓기도 했지만 정말 힘든 사람도 만나기도 했고… <br /></p>

<p><img src="../../../assets/mudo_desperation.jpg" width="700" height="170" /></p>

<p>그래도 감사한 건 5학기, 정말 좋은 타이밍에 너무 귀중한 것들을 깨달았다는 것이다. 공부는 체력 싸움이라는 말을 처음으로 이해했고 방학 때 운동도 꾸준히 했다. 크고 어려운 과제를 어떻게 풀어가야 하는가에 대한 방법론을 고민해보게 되었다. 방학 때는 정말 많은 논문을 읽으면서 연구 주제에 대한 식견을 넓혔다. 쉼의 중요성도 느끼면서 중간 중간 쉬는 방법도 깨달았고 2년 만에 못 봤던 친구들도 많이 만났다. <br /></p>

<p>무엇보다 멘탈의 중요성을 느낀 학기였다. 솔직히 그렇게 크게 무너진 것도 아니였고 갑자기 모든 걸 놓아버리는 일이 있었던 것도 아니었다. 그러나 내 자신이 너무 지쳤던 학기였다. 충분히 만족할 만한 퍼포먼스를 보였고 걱정한 것보다도 훨씬 잘했지만 멘탈을 조금만 챙겼더라면 더 잘할 수 있지 않았을까 라는 아쉬움이 너무나도 크게 다가왔다. 그렇기에 6학기가 너무 기대된다. 이러한 위기 아닌 위기를 겪으면서 멘탈이 강화된 것 같다는 가설(?)을 증명하고 싶다. 뿐만 아니라 새로운 과목들을 (특히 내가 너무 기대하고 있는 Programming Language Theory) 듣는다. 이제는 공식적으로 연구자로서의 미미한 발걸음을 내딛는다. 랩실 생활에 적응했고 수민이가 없는 학교에 적응했다. TA로서도 학생들을 더 잘 도와줄 수 있지 않을까 라는 생각이 든다. <br /></p>

<p>6학기를 앞두며 이제는 내가 목표한 바를 이루기 위해서 최선을 다 할 일밖에 남지 않았다고 생각한다. 지금까지 잘 해왔고 계속해온 것처럼 노력한다면 목표한 바를 충분히 이룰 수 있다고 생각한다. 지금까지 잘해왔고 잘하고 있다! <br /></p>

<p>무엇보다 바쁜 학기 가운데 신앙을 잃지 않았으면 한다.</p>]]></content><author><name>JSC</name><email>newwin0198@handong.ac.kr</email></author><category term="Blog" /><category term="Blog" /><summary type="html"><![CDATA[6th Semster]]></summary></entry><entry><title type="html">And Then There Were None 그리고 아무도 없었다</title><link href="http://localhost:4000/recent/And_Then_There_Were_None/" rel="alternate" type="text/html" title="And Then There Were None 그리고 아무도 없었다" /><published>2023-07-16T00:00:00+09:00</published><updated>2023-07-16T00:00:00+09:00</updated><id>http://localhost:4000/recent/And_Then_There_Were_None</id><content type="html" xml:base="http://localhost:4000/recent/And_Then_There_Were_None/"><![CDATA[<p>추리 소설을 추천받았다. 아가사 크리스티의 <strong><em>그리고 아무도 없었다</em></strong> 였다. <br /> 
소설을 그렇게 좋아하는 편은 아니라 이름만 들어본 작가였지만 오랜만에 소설을 읽어보자는 마음으로 책을 집어들었다.</p>

<p>와우. 정말 재밌게 읽었다. 그 자리에 앉아서 내리 2시간을 읽었다. <del>물론 소설이 짧기도 하다</del> <br />
알고 보니 내 주위는 다들 읽었더라… 이 재밌는 걸 자신들만 알고 있었다니…</p>

<p>물론 선입견빼면 시체인 내가 추리 소설을 추천 받았더라도 내가 내키지 않았으면 안 읽었을 것 같긴 하다.
뭐든지 한 번 정도 시도해보고 판단하는게 맞는 것 같다는 생각이 근래에 많이 든다.</p>

<p>그 정도로 책이 재밌었다. 다음엔 <strong><em>오리엔트 특급 살인</em></strong> 읽어볼까 싶다!</p>]]></content><author><name>JSC</name><email>newwin0198@handong.ac.kr</email></author><category term="Books" /><category term="Blog" /><summary type="html"><![CDATA[재밌다...]]></summary></entry><entry><title type="html">Clean Code Chapter 3</title><link href="http://localhost:4000/recent/Clean_Code_Ch3/" rel="alternate" type="text/html" title="Clean Code Chapter 3" /><published>2023-07-16T00:00:00+09:00</published><updated>2023-07-16T00:00:00+09:00</updated><id>http://localhost:4000/recent/Clean_Code_Ch3</id><content type="html" xml:base="http://localhost:4000/recent/Clean_Code_Ch3/"><![CDATA[<p>How can we make a function communicate its intent?</p>

<p>What attributes can we give that will allow a reader to intuit the kind of program they live inside?</p>

<p><strong><em>The function should be very small</em></strong></p>

<ul>
  <li>In 1999, every function was just two, three, or four lines long
    <ul>
      <li>Each was transparent and led to the next in a compelling order</li>
    </ul>
  </li>
  <li>Block and Indenting
    <ul>
      <li>block within if, else, while and so on should be one line long
        <ul>
          <li>The line must be a function call</li>
          <li>The function should not be large enough to hold the nested structure</li>
          <li>The indent level of a function should not be greater than one or two</li>
        </ul>
      </li>
    </ul>

    <p><strong><em>Function Should Do One Thing</em></strong></p>
  </li>
  <li>What is one thing?
    <ul>
      <li>If a function does only that is on one level below the stated name of the function, then the function is doing one thing</li>
      <li>Decomposing a larger concept</li>
      <li>Simply restates the code without changing the level of abstraction</li>
      <li>if you can extract another function from it with a name that is not merely a restatement of its implementation</li>
      <li>A function that does one thing cannot be divided</li>
    </ul>
  </li>
  <li>One level of abstraction per function
    <ul>
      <li>Statements within the function are all at the same level of abstraction</li>
    </ul>
  </li>
  <li>Reading code from Top to Bottom: The Stepdown Rule
    <ul>
      <li>Top-down Narrative</li>
      <li>Reading program, descending one level of abstraction at a time as we read down the list of function</li>
      <li>Each function introduces the nest, and each function remains at a consistent level of abstraction</li>
    </ul>
  </li>
  <li>Avoid using switch statements
    <ul>
      <li>Each statement is buried in a low-level class and is never repeated</li>
      <li>Switch Statements can be tolerated if they appear only once</li>
      <li>Used to create polymorphic objects; hidden behind an inheritance relationship</li>
    </ul>
  </li>
  <li>Simple Responsibility Principle
    <ul>
      <li><a href="https://en.wikipedia.org/wiki/Single-responsibility_principle">https://en.wikipedia.org/wiki/Single-responsibility_principle</a></li>
    </ul>
  </li>
  <li>Open Closed Principle
    <ul>
      <li><a href="https://en.wikipedia.org/wiki/Open%E2%80%93closed_principle">https://en.wikipedia.org/wiki/Open–closed_principle</a></li>
    </ul>
  </li>
  <li>Use Descriptive Names
    <ul>
      <li>Choose descriptive names to clarify the design of the module in mind</li>
      <li>Don’t be afraid to make a name long</li>
      <li>Be consistent in names</li>
    </ul>
  </li>
</ul>

<p><strong><em>The argument is at a different level of abstraction</em></strong></p>

<ul>
  <li>Function Arguments
    <ul>
      <li>The ideal number argument for a function is zero(niladic)</li>
      <li>An argument forces the user to know the details</li>
    </ul>
  </li>
  <li>Arguments are hard at the testing point of a view
    <ul>
      <li>Need to test all combinations of arguments</li>
      <li>Output arguments are harder to understand than input arguments</li>
      <li>Don’t expect information to be going out through arguments</li>
    </ul>
  </li>
  <li>Common Monadic(one argument) function
    <ul>
      <li>Usage of arguments
        <ul>
          <li>Asking questions about arguments</li>
          <li>Operating on arguments, transforming the arguments</li>
        </ul>
      </li>
      <li><em>Event: there are input arguments but no output arguments</em>
        <ul>
          <li>The intention of calling the event is to use the argument the alter the state of the system</li>
          <li>Usage should be very clear that reader must notice this function is the event</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>Flag Arguments
    <ul>
      <li><em>It is Ugly</em></li>
      <li>Split function instead of flag</li>
    </ul>
  </li>
</ul>

<p>Dyadic Functions</p>

<ul>
  <li>Should be avoided, but there is a situation in that dyadic function is necessary</li>
  <li>Take advantage of what mechanisms may be available to convert them into single-argument functions</li>
</ul>

<p>Triads Functions</p>

<ul>
  <li>Very careful to use it</li>
</ul>

<p>Argument Objects</p>

<ul>
  <li>When a group of variables is passed together, it is likely part of a concept that deserves a name of its own</li>
  <li>Augment list
    <ul>
      <li>Functions that take variable arguments can be monads, dyads, or even triads, but no more than that</li>
    </ul>
  </li>
</ul>

<p>Verb and Keywords</p>

<ul>
  <li>Monad case
    <ul>
      <li>the function and argument should form a very nice verb/noun pair</li>
    </ul>
  </li>
  <li>Using keywords to form a function name</li>
  <li>Function name and ordering of argument</li>
  <li>No side Effect
    <ul>
      <li>No temporal coupling</li>
      <li>State exactly what the function does and split the function if it is possible</li>
    </ul>
  </li>
  <li>Output arguments
    <ul>
      <li>Anything that forces you to check the function signature is equivalent to a double-take</li>
      <li><em>this</em> keyword is intended to act as an output argument</li>
      <li>Output argument should be avoided</li>
    </ul>
  </li>
</ul>

<p><strong><em>Do something or answer something, but not both</em></strong></p>

<p>Command Query Separation</p>

<ul>
  <li>Separate the command from the query so that ambiguity cannot occur</li>
</ul>

<p>Prefer Exception to Return Error Codes</p>

<ul>
  <li>Processing code can be separated from the happy path code and can be simplified</li>
  <li>Extract Try/Catch Block
    <ul>
      <li>Specific function for error handling</li>
      <li>It makes help to clarify the function
        <ul>
          <li>Nice Separation</li>
        </ul>
      </li>
      <li>Error Handling is one thing; function should only be one thing</li>
    </ul>
  </li>
  <li>New exceptions are derivatives of the exception class</li>
</ul>

<p>Don’t Repeat Yourself</p>

<ul>
  <li>Duplication may be the root of all evil in software</li>
  <li>Since the invention of the subroutine, innovations have been an ongoing attempt to eliminate duplication from our source code</li>
</ul>

<p>Structured Programming</p>

<ul>
  <li>Only be one <em>return</em> statement</li>
  <li>No <em>break</em> or <em>continue</em> statement</li>
  <li>Never <em>goto</em> statement</li>
  <li>These rules are beneficial for large functions, not small functions</li>
</ul>

<p>How to write a function with these rules?</p>

<ul>
  <li>Write code</li>
  <li>Message and refine the code, shrink and reorder, and keeping the test passing</li>
</ul>

<p>Conclusion</p>

<ul>
  <li>Functions are the verb</li>
  <li>Classes are the nouns</li>
  <li>The art of programming is the art of language design</li>
  <li>A function will be short, well-named, nicely organized</li>
  <li><strong><em>Tell the story of the system</em></strong>
    <ul>
      <li>need to fit cleanly together in precise language</li>
    </ul>
  </li>
</ul>]]></content><author><name>JSC</name><email>newwin0198@handong.ac.kr</email></author><category term="Books" /><category term="Blog" /><summary type="html"><![CDATA[Using Function Properly]]></summary></entry><entry><title type="html">Can We Automatically Fix Bugs by Learning Edit Operations?</title><link href="http://localhost:4000/recent/Can-We-Automatically-Fix-Bugs-by-Learning-Edit-Operations/" rel="alternate" type="text/html" title="Can We Automatically Fix Bugs by Learning Edit Operations?" /><published>2023-07-13T00:00:00+09:00</published><updated>2023-07-13T00:00:00+09:00</updated><id>http://localhost:4000/recent/Can%20We%20Automatically%20Fix%20Bugs%20by%20Learning%20Edit%20Operations</id><content type="html" xml:base="http://localhost:4000/recent/Can-We-Automatically-Fix-Bugs-by-Learning-Edit-Operations/"><![CDATA[<h2 id="can-we-automatically-fix-bugs-by-learning-edit-operations">“Can We Automatically Fix Bugs by Learning Edit Operations?”</h2>

<h2 id="paper"><a href="https://www.cs.wm.edu/~denys/pubs/SANER-RENE-BugFixing.pdf">Paper</a></h2>

<h3 id="summary">Summary:</h3>

<ul>
  <li>
    <p>Implementing Hephaestus, a novel method to improve the accuracy of APR through learning to apply edit operations. Leverages neural machine translation and attempts to produce the edit operations needed.</p>

    <p>Learning edit operations does not offer an advantage over the standard approach of translating directly from buggy code to fixed code. However, interestingly, Hephaestus exhibited lower translation accuracy than the baseline, able to perform successful bug repair.</p>
  </li>
</ul>

<h3 id="points">Points:</h3>

<ol>
  <li>Introduction
    <ol>
      <li>The naive approach attempts some sort of comparison algorithm that identifies the type of bug and replaces it with a prescribed bugs
        <ol>
          <li>Time Consuming</li>
        </ol>
      </li>
      <li>Learning approach using neural machine translation</li>
      <li>Directly applying the NMT approach to source code is inefficient
        <ol>
          <li>Many bugs fixes involve changes to a few sentences
            <ol>
              <li>Results in suboptimal performances</li>
            </ol>
          </li>
          <li>Attempt to mitigate the inefficiency by predicting the specific statement on AST</li>
          <li>Attempting on individual tokens would be more optimal</li>
        </ol>
      </li>
      <li>Hephaestus leverages NMT to predict edit operation, derived from Levenshtein Distance Algorithm
        <ol>
          <li>Working at the token level of source code</li>
          <li>Work on any language without language-specific parsers</li>
        </ol>
      </li>
    </ol>
  </li>
  <li>Related Works
    <ol>
      <li>Tufano et al.
        <ol>
          <li>Repairing code through identification of bug-fix patterns in large software repositories</li>
          <li>Usage of Deep Learning Approach regarding “meaningful” change</li>
        </ol>
      </li>
      <li>Chen et al.
        <ol>
          <li>Focus on single-line bug</li>
        </ol>
      </li>
      <li>Jiang et al.
        <ol>
          <li>The correct fix for a given bug does not exist within the model’s output space and the model’s lack of awareness of syntax</li>
          <li>Pre-train model on the programming language in question</li>
        </ol>
      </li>
      <li>Yuan and Banzhaf
        <ol>
          <li>grouping fine-granularity edits into larger statement-level edits</li>
        </ol>
      </li>
      <li>Mousavi et al.
        <ol>
          <li>Overfitting and Disparity between predicted bug and fix operation and would mimic a human software developer</li>
        </ol>
      </li>
    </ol>
  </li>
  <li>Background
    <ol>
      <li>Fixing buggy code to fixed code using traditional language translation matter of the buggy to fix a variety of language</li>
      <li>Traditional translation replaces the majority of the input sequence which is natural language.
        <ol>
          <li>Fix in code might be minimal</li>
          <li>repair translation should not have the same meaning as the input</li>
        </ol>
      </li>
    </ol>
  </li>
  <li>Approach
    <ol>
      <li>Levenshtein Edit Operation
        <ol>
          <li>the bug is input sequence, the NMT model attempts to produce edit operations</li>
          <li>Basic Operations
            <ol>
              <li>Insertion</li>
              <li>Deletion</li>
              <li>Replacement</li>
            </ol>
          </li>
        </ol>
      </li>
      <li>Compound Edit Operations
        <ol>
          <li>Group of one or more edit operations; sequence of operations</li>
          <li>Condensing: A grouping process to compound operations</li>
        </ol>
      </li>
      <li>Dataset Construction
        <ol>
          <li>Control Dataset: baseline, not involved with edit operations</li>
          <li>Machine String: In order to include edit operations, transforming edit operations
            <ol>
              <li>Typed</li>
              <li>General</li>
            </ol>
          </li>
          <li>We make the distinction between typed and general form to determine if the form of machine string used during training affects the Hephaestus models’ abilities to learn edit operations.</li>
        </ol>
      </li>
      <li>Experimental Dataset
        <ol>
          <li>translate the bug into its corresponding fix, showing Levenshetein edit distance between the bug and fix</li>
          <li>all basic compound operation sequences which transform the bug into the fix, strict is the minimal sequence of the strict compound operation sequences, and loose is the minimal sequence of the loose compound operation sequences</li>
        </ol>
      </li>
      <li>Model Construction
        <ol>
          <li>LSTM+General</li>
          <li>GRU+General</li>
          <li>LSTM+Typed</li>
        </ol>
      </li>
      <li>The CEC ensures that error signals fed forward into the LSTM layers and backpropagated to the LSTM layers are resistant to the effects of the vanishing gradient problem.</li>
    </ol>
  </li>
  <li>Experimental Design
    <ol>
      <li>Perfect Prediction Accuracy</li>
      <li>Failed Prediction Rate</li>
      <li>Edit Distance Decrease</li>
      <li>Training Accuracy</li>
    </ol>
  </li>
  <li>Result
    <ol>
      <li>PPA: The control model (baseline model) outperformed the rest, with no much difference</li>
      <li>FPR: The control model maintained 100% capability, the string can always be interpreted as a sequence of Java method tokens</li>
      <li>EDD: every model generates “bug fixes” that were further away from the fixed code than the original buggy code</li>
      <li>Training Accuracy: Every model exceeded 90%</li>
    </ol>
  </li>
  <li>RQ
    <ol>
      <li>RQ1: Is learning edit operations an effective approach to automatic bug repair?
        <ol>
          <li>learning edit operations does not offer advantages over the baseline approach. The experimental Hephaestus models must determine a sequence of edit operations, decode them, and apply them to the inputted buggy method in order to predict fixed source code</li>
        </ol>
      </li>
      <li>RQ2: What effect does each condensing strategy and machine string form have on the accuracy of bug repair?
        <ol>
          <li>The differences in PPA between the basic, strict, and loose models are negligible, but there are differences according to the training accuracy and average EDD values. Despite having significantly lower final training accuracy, the strict and loose models had slightly more positive EDD values than the basic models (a difference of about 0.96). Thus, it is evidenced that condensing edit operations into strict and loose forms are beneficial over not condensing them at all</li>
        </ol>
      </li>
      <li>RQ3: What is the effect of using an LSTM-based architecture versus a GRU-based architecture on the accuracy of bug repair?
        <ol>
          <li>the variation is not meaningful enough to consider as a key difference between the models.</li>
        </ol>
      </li>
      <li>Future Work
        <ol>
          <li>It was determined that most failed predictions were caused by generated indices outside the valid range for a given string. What changes can be made to this model to restrict the prediction range?</li>
          <li>does changing the abstraction method of the training dataset affect this metric?</li>
          <li>Other NLP Tools</li>
          <li>Extra software layers in addition to the methods presented in our study.</li>
        </ol>
      </li>
      <li>Conclusion
        <ol>
          <li>The introduction of these specific methods for training NMTbased systems to learn bug fixes did not provide a benefit to the task</li>
          <li>Edit operations are capable of performing automated bug repair to some degree</li>
        </ol>
      </li>
    </ol>
  </li>
</ol>

<h3 id="knowledge">Knowledge:</h3>

<ul>
  <li>NMT (Neural Machine Translation): <a href="https://en.wikipedia.org/wiki/Neural_machine_translation">Neural machine translation - Wikipedia</a>uses an artificial neural work to predict the likelihood of a sequence of words</li>
  <li>Levenshtein Distance Algorithm: A string metric for measuring the difference between two sequences. This is likely due to the experimental models experiencing higher entropy than the control when making predictions.</li>
</ul>

<h3 id="terminology">Terminology:</h3>

<ul>
  <li>Condensing Strategies:
    <ul>
      <li>Basic Condensing: basic compound operation corresponds with exactly one change</li>
      <li>Loose Condensing: iff the application of its constituent operation is equivalent to the application of some singular op
        <ul>
          <li>Modify a contiguous section of tokens</li>
        </ul>
      </li>
      <li>Strict Condensing: iff it is loosely compatible and every operation is of the same flavor</li>
    </ul>
  </li>
  <li>Machine Strings:
    <ul>
      <li>Typed: f is one of ins, del, or rep, depending on if the flavor of the represented edit operation is insertion, deletion, or replacement, respectively</li>
      <li>General: general form machine strings do not explicitly store the flavor of their represented edit operations</li>
    </ul>
  </li>
</ul>

<h3 id="tool">Tool:</h3>

<p><a href="https://github.com/WM-SEMERU/hephaestus">GitHub - WM-SEMERU/hephaestus</a></p>

<h3 id="questions">Questions:</h3>]]></content><author><name>JSC</name><email>newwin0198@handong.ac.kr</email></author><category term="APR" /><category term="APR" /><summary type="html"><![CDATA[Generalizing the change is helpful...?]]></summary></entry><entry><title type="html">Clean Code Chapter 1</title><link href="http://localhost:4000/recent/Clean_Code_Ch1/" rel="alternate" type="text/html" title="Clean Code Chapter 1" /><published>2023-07-13T00:00:00+09:00</published><updated>2023-07-13T00:00:00+09:00</updated><id>http://localhost:4000/recent/Clean_Code_Ch1</id><content type="html" xml:base="http://localhost:4000/recent/Clean_Code_Ch1/"><![CDATA[<ul>
  <li>What is Clean Code?
    <ul>
      <li>Bjarne Stroustrup, Inventor of C++
        <ul>
          <li>Wasted Cycle are inelegant, not pleasing</li>
          <li>Error handling should be complete</li>
          <li>Focused; Each function, class, and module expose a single-minded attitude that remains entirely undistracted, and unpolluted, by the surrounding details</li>
        </ul>
      </li>
      <li>Grady Booch, author of Object Oriented Analysis and Design with Application
        <ul>
          <li>He took a readability perspective</li>
          <li>Well-written purpose</li>
          <li>clean code should clearly expose the tensions in the problem to be solved</li>
          <li>Should be matter-of-fact as opposed to speculative</li>
        </ul>
      </li>
      <li>Dave Thomas, founder of OTI
        <ul>
          <li>Make it easy for other people to enhance it</li>
          <li>Code without test is not clean at all</li>
          <li>values code that is small, code should be literate</li>
        </ul>
      </li>
      <li>Michael Feathers, author of Working Effectively with Legacy Code
        <ul>
          <li>Looks like it was written by someone who cares</li>
          <li>Someone has taken the time to keep it simple and orderly</li>
        </ul>
      </li>
      <li>Ron Jeffries, author of Extreme Programming Installed and Extreme Programming Adventures in C#
        <ul>
          <li>No duplications</li>
          <li>Express all the design ideas
            <ul>
              <li>High expressiveness</li>
            </ul>
          </li>
          <li>Minimize the number of entities
            <ul>
              <li>Find things in a collection</li>
              <li>Wrap particular implementation in a more abstract method</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>Ward Cunningham, inventor of Wiki, inventor of Fit …
        <ul>
          <li>read turns out what you expected</li>
          <li>make it look like the language was made for the problem</li>
          <li>It is the programmer that makes the language appear simple</li>
        </ul>
      </li>
      <li>Author: <a href="https://www.google.com/search?q=Robert+C.+Martin&amp;stick=H4sIAAAAAAAAAONgVuLWz9U3MDSqMspOT3rEaMYt8PLHPWEp3UlrTl5jVOfiCs7IL3fNK8ksqRSS5GKDsvileLmQ9fEsYhUIyk9KLSpRcNZT8E0sKsnMAwD4hk_pWwAAAA&amp;sa=X&amp;ved=2ahUKEwjDuvb5qYSAAxWJAt4KHYeWALQQzIcDKAB6BAgiEAE">Robert Cecil Martin</a>
        <ul>
          <li>Discovering new techniques and founding their own schools</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p>Many Recommendations in this book are controversial.</p>

<p>And we are <strong>AUTHORS</strong>.</p>

<ul>
  <li>Making it Easy to read makes it easier to write</li>
  <li>The code has to be kept clean over time</li>
</ul>

<p>This book cannot promise to make you a good programmer.</p>

<p><strong>“Practice, son. Practice!”</strong></p>]]></content><author><name>JSC</name><email>newwin0198@handong.ac.kr</email></author><category term="Books" /><category term="Blog" /><summary type="html"><![CDATA[What is Clean Code?]]></summary></entry><entry><title type="html">Clean Code Chapter 2</title><link href="http://localhost:4000/recent/Clean_Code_Ch2/" rel="alternate" type="text/html" title="Clean Code Chapter 2" /><published>2023-07-13T00:00:00+09:00</published><updated>2023-07-13T00:00:00+09:00</updated><id>http://localhost:4000/recent/Clean_Code_Ch2</id><content type="html" xml:base="http://localhost:4000/recent/Clean_Code_Ch2/"><![CDATA[<p><strong>Using the appropriate Name will pay off in the short term and continue to pay in the long run</strong></p>

<ul>
  <li>Using Intention-Revealing Names
    <ul>
      <li>Choosing good names takes time but saves more than it takes</li>
      <li>Choosing a name that specifies what is being measured and the unit of that measurement</li>
      <li>Things need to think
        <ul>
          <li>What kind are in</li>
          <li>What is returned</li>
          <li>zeroth subscript and value</li>
        </ul>
      </li>
      <li>Do not use <strong>O <em>and l</em></strong></li>
    </ul>
  </li>
  <li>Avoid Disinformation
    <ul>
      <li>Avoiding words whose entrenched meanings vary from intention</li>
      <li>Spelling similar concepts similarly
        <ul>
          <li>No inconsistent spelling</li>
        </ul>
      </li>
      <li><del>Using different font??</del></li>
    </ul>
  </li>
  <li>Meaningful Distinction
    <ul>
      <li><strong>a</strong> for a local variable, <strong>the</strong> for all function arguments</li>
      <li>Less redundant words</li>
      <li>Distinguishing names in a way that readers know what the difference offer</li>
    </ul>
  </li>
  <li>Using Pronounceable Names
    <ul>
      <li>Essential for communication</li>
    </ul>
  </li>
  <li>Using Searchable Names
    <ul>
      <li>Single-letter names can ONLY be used as local variables inside short methods</li>
      <li>The length of a name should correspond to the size of its scope</li>
    </ul>
  </li>
  <li>Avoiding Encoding</li>
  <li>Hungarian Notation
    <ul>
      <li>The compiler knows the type nowadays</li>
    </ul>
  </li>
  <li>Member Prefixes
    <ul>
      <li>unseen clutter and a marker of older code…</li>
    </ul>
  </li>
  <li>Interface and Implementation
    <ul>
      <li>Why would I let user knows I’m handling them with an interface?</li>
      <li>Marking at the implementation</li>
    </ul>
  </li>
  <li>Avoid Mental Mapping
    <ul>
      <li>In most contexts, a single letter for a loop is a poor choice (such as i, j, k)</li>
      <li><em>Clarity is king</em></li>
    </ul>
  </li>
  <li>Class Names
    <ul>
      <li>should have noun or noun phrase names</li>
    </ul>
  </li>
  <li>Method Names
    <ul>
      <li>should have verb or verb phase names</li>
      <li>When constructors are overloaded, use the static method with names that describe the argument
        <ul>
          <li>Make corresponding constructors private</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>Don’t be cute
    <ul>
      <li>No too “user-specific name”</li>
    </ul>
  </li>
  <li>Pick One Word per Concept
    <ul>
      <li>Pick one word for one abstract concept</li>
      <li>The name will express two different types of object</li>
    </ul>
  </li>
  <li>Don’t Pun
    <ul>
      <li>Avoiding using the same word for two purposes</li>
      <li>Even if it has a similar concept, it must have a different name if it is semantically different</li>
      <li><strong><em>It is the author’s responsibility</em></strong></li>
    </ul>
  </li>
  <li>Use Solution Domain Names
    <ul>
      <li>People who read your code will be programmers
        <ul>
          <li>CS terms, algorithm names, pattern names, math terms, etc.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>Use Problem Domain Names
    <ul>
      <li>Separating solution and problem domain concept</li>
    </ul>
  </li>
  <li>Add Meaningful Context
    <ul>
      <li>Place the name in context for the reader
        <ul>
          <li>enclosing classes, functions, or namespaces</li>
        </ul>
      </li>
      <li>break it into smaller functions if it is necessary</li>
    </ul>
  </li>
  <li>But Don’t Add Gratuitous Context
    <ul>
      <li>Shorter names are generally better
        <ul>
          <li>As long as they are clear</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>]]></content><author><name>JSC</name><email>newwin0198@handong.ac.kr</email></author><category term="Books" /><category term="Blog" /><summary type="html"><![CDATA[How to name clearly]]></summary></entry><entry><title type="html">Automatic Patch Generation with Context-based Change Application</title><link href="http://localhost:4000/recent/ConFix/" rel="alternate" type="text/html" title="Automatic Patch Generation with Context-based Change Application" /><published>2023-07-10T00:00:00+09:00</published><updated>2023-07-10T00:00:00+09:00</updated><id>http://localhost:4000/recent/ConFix</id><content type="html" xml:base="http://localhost:4000/recent/ConFix/"><![CDATA[<h3 id="automatic-patch-generation-with-context-based-change-application">Automatic Patch Generation with Context-based Change Application</h3>

<h2 id="paper"><a href="https://raw.githubusercontent.com/wiki/thwak/ConFix/pre-print.pdf">Paper</a></h2>

<p>Jindae Kim, Sunghun Kim</p>

<h3 id="goal">Goal:</h3>

<ol>
  <li>I am collecting changes from human-written patches for new patch candidate generation.</li>
  <li>Automatic patch generation technique leveraging human-written patches with our context-based change application technique used by ConFix.</li>
</ol>

<h3 id="summary">Summary:</h3>

<ul>
  <li>An effective patch generation technique should have a large search space with a high probability that patches for bugs are included, and it also needs to locate such patches effectively. Confix collects abstract AST changes from human-written patches, providing resources for patch generation. Then, using only matching context only, Confix selects a necessary change for a possible fixed location. Also, Confix filters out undesirable locations to fix using the info that the location has not been changed in human-written patches.</li>
</ul>

<h3 id="points">Points:</h3>

<ol>
  <li>The problem with APR is search space size and navigation.
    <ol>
      <li>To solve the problem, mining changes from human-written patches has been trying, but it makes navigation for the patch more difficult since the changes are very sparse.</li>
      <li>Confix, use context-based change application technique to generate patch candidates.
        <ol>
          <li>AST context applies collected change to a possible fixed location only if their AST contents are matched</li>
          <li>ConFix compares AST contexts defined by parent, left, and right nodes of a change and a location and applies the change to a target location only if their contexts are matched.</li>
        </ol>
      </li>
    </ol>
  </li>
  <li>Change Collection
    <ol>
      <li>Collecting changes generally applicable to other location</li>
      <li>We extract AST form since source code can be easily affected by specific user styles.</li>
      <li>Following some steps, dependent on how changes are collected</li>
    </ol>
  </li>
  <li>Change Extraction
    <ol>
      <li>Each hunk is extracted and converted to an individual AST subtree change.</li>
      <li>Collect separate individual changes rather than the whole patch to use repetitiveness of changes.</li>
      <li>To extract changes, use the differencing tool, generates AST subtree edit operation, combine node edit operation into trees
        <ol>
          <li>AST node type and node value indicate a specific identifier, literals, or operators; the edit operation preserves the AST structure of the inserted code fragment</li>
        </ol>
      </li>
    </ol>
  </li>
  <li>Change conversion
    <ol>
      <li>Extracted edit operations need to be independent and applicable form.
        <ol>
          <li>The type needs to be changed as a single change
            <ol>
              <li>divide operation more</li>
              <li>extends operation</li>
              <li>remove any operation if a changed AST is a subtree of another operation’s changed AST</li>
              <li>Find all inserted-delete pairs applied to the same location and combine them.</li>
            </ol>
          </li>
        </ol>
      </li>
      <li>Need to normalize the user-defined identifiers.
        <ol>
          <li>By normalizing user-defined names, we can increase the reusability of collected changes since we can apply a change regardless of the availability of user-defined names.</li>
          <li>The technique normalizes user-defined names with two principles: consistency and order-preserving</li>
          <li>By normalizing user-defined names, we can increase the reusability of collected changes since we can apply a change regardless of the availability of user-defined names.</li>
          <li>At the time of change concretization, the collected information works as requirements for each abstract name which ConFix should consider when it assigns a concrete name for the abstract name.</li>
        </ol>
      </li>
      <li>Change Context Identification
        <ol>
          <li>After individual changes are obtained from source code patches, the next step is identifying the AST contexts of the changes.</li>
          <li>By identifying the context of the target location, we can avoid meaningless modifications and more frequent changes.</li>
          <li>To define AST context, use nearby nodes of a changed AST subtree
            <ol>
              <li>The parent node represents the location where a changed code fragment belongs.</li>
              <li>The left and Right nodes indicate code fragments before and after the changed code fragment.</li>
              <li>Using fingerprinting technique</li>
              <li>Dyck Word Hash
                <ol>
                  <li>represents the parent-child relationship of nodes</li>
                  <li>Compare two nodes’ hash values to check whether they are the roots of two type-isomorphic AST subtrees.</li>
                  <li>For fast comparison</li>
                </ol>
              </li>
            </ol>
          </li>
          <li>PLRTH and PLRT
            <ol>
              <li>left node indicates code before the changed code frame; the right node indicates code after the changed code fragment</li>
              <li>PTLRH context, we also examine whether the change and the location have the same code fragment before and after them, while PLRT context only checks which kind of code fragments exist before and after the change and the location.</li>
              <li>PTLRH context constrains the search area too much; we can expand the search area with PLRT context.</li>
              <li>Exception</li>
              <li>Block node does not mean too much; use its parent node as a type.</li>
              <li>Move operations primarily consider the old location’s context, but store the new location’s context to use it as an additional constraint of move changes.</li>
            </ol>
          </li>
        </ol>
      </li>
    </ol>
  </li>
  <li>Change Application
    <ol>
      <li>Target Location Context Identification
        <ol>
          <li>The target location is also an AST node to which a change will be applied</li>
          <li>To identify the location context is compatible with change contexts, using PLR nodes we can identify location contexts for changes
            <ol>
              <li>Except for insert, another operation has an old AST subtree so it is applicable</li>
              <li>The inserted context is identified from New AST which is inserted. We need a different type, based on the assumption that a subtree is inserted near a location. Insert Before and Insert After contexts are the contexts for cases in which a new AST subtree is inserted before and after node N. Node C indicates the actual location where a subtree will be inserted</li>
            </ol>
          </li>
        </ol>
      </li>
    </ol>
  </li>
  <li>Change Selection
    <ol>
      <li>retrieve changes with the same context from a changing pool</li>
      <li>Categorized by their context, only store unique changes with their frequency</li>
      <li>choose one of the selections and mimic human-written changes by selecting any of the changes on the list
        <ol>
          <li>The random selection, strategy is not decided specifically</li>
        </ol>
      </li>
    </ol>
  </li>
  <li>Change Concretiziation
    <ol>
      <li>Replacing all normalized identifiers with concrete name
        <ol>
          <li>Do not fully specify the strategy yet how ConFix concretizes a change since various strategies can be used</li>
          <li>Since the type of normalized variables and signature of normalized methods are also stored during change collection, we can consider a strategy that assigns an existing variable name to a normalized variable (if the type is compatible)</li>
          <li>Since change is concretized, apply it to the target location</li>
        </ol>
      </li>
    </ol>
  </li>
  <li>Patch generation
    <ol>
      <li>Generate-and-validate process</li>
      <li>Starts with the PTLRH pool to narrow down the search area for patch generation, switch to PLRT if the patch generation failed at the above level</li>
      <li>Identify target location, retrieves changes having the same context as the selected location, apply it to the target location</li>
      <li>Lastly, tries different name assignments by predefined max trials
        <ol>
          <li>To prevent spoiled validation due to wrong name assignment</li>
        </ol>
      </li>
      <li>Pass -&gt; termination; Fail -&gt; continues with another change</li>
      <li>When it reaches the max candidate, moves to the next change pool</li>
    </ol>
  </li>
  <li>Target Location Identification
    <ol>
      <li>Confix leverages both fault localization and change context to identify target locations from given buggy code
        <ol>
          <li>Identifies all AST nodes which belong to the statement as potential target locations</li>
          <li>filters out all target locations having context not included in the current change pool</li>
          <li>Identify fail and pass a group
            <ol>
              <li>The first pick from the fail-only group, if there is no location, starts from the pass-fail group</li>
              <li>Failing test cases have a much higher priority</li>
            </ol>
          </li>
          <li>Prior target location has if, method invocation, infix expression, or return statement since it influences the whole execution</li>
        </ol>
      </li>
    </ol>
  </li>
  <li>Change Selection
    <ol>
      <li>ConFix selects one of the retrieved changes for the current target location and chooses the most frequent change</li>
      <li>Even if it is in the same context, change might not be applicable
        <ol>
          <li>In case of replacement operation, one more location should be selected</li>
          <li>Therefore, ConFix randomly selects one of the target locations with a matching context
            <ol>
              <li>If there is not, discard the change</li>
            </ol>
          </li>
        </ol>
      </li>
      <li>Code might not be compilable, so ConFix goes through the verification steps
        <ol>
          <li>Examine all change-location pairs since a change that was applicable in another location might not be applicable in other locations</li>
          <li>Considering all pairs and compiling is beneficial rather than since it is not expensive to recompile source code with a small modification</li>
        </ol>
      </li>
    </ol>
  </li>
  <li>Change Concretization
    <ol>
      <li>Concretizing selected change for the target location</li>
      <li>ConFix collects concrete names of variables, types, and methods from the given buggy code and decides which names are within the scope</li>
      <li>To find a concrete method for a normalized method, ConFix identifies compatible methods from collected methods available at a target location</li>
      <li>Abstract signature
        <ol>
          <li>method signature with normalized types</li>
          <li>The purpose of this is to find a concrete method with the same abstract signature, then it will not cause a compile error</li>
        </ol>
      </li>
      <li>Assignable type
        <ol>
          <li>Consider both type compatibility and the number of variables of the types
            <ol>
              <li>Normalized types are considered wildcard characters, which means that they can be assignable to either normalized types or JSL types.</li>
              <li>ConFix only considers a type as assignable to another type if there exist enough variables for assignment.</li>
            </ol>
          </li>
          <li>the compatibility of a normalized and a concrete method is defined by their abstract signatures and assignable types
            <ol>
              <li>The concrete method first considers local methods, then global methods with the assumption that local methods are more closely related to buggy code</li>
              <li>Once a concrete method for a normalized method is selected and assigned, ConFix update types are matched due to method assignment</li>
              <li>Randomly assigns one of the assignable concrete types for each normalized type</li>
              <li>Assigns concrete variables to normalized variables</li>
            </ol>
          </li>
          <li>There is one additional treatment for update type changes which updates an identifier with another identifier
            <ol>
              <li>Assume the update change is meaningful when the new name is similar to the old one, so calculate the Levenshtein distance between the identifier and concrete name</li>
            </ol>
          </li>
          <li>In case of no type-compatible assignment
            <ol>
              <li>Change concretization is considered failed and no patch candidate is generated</li>
            </ol>
          </li>
        </ol>
      </li>
    </ol>
  </li>
  <li>Evaluation
    <ol>
      <li>Collected changes with PTLRH and PTLR contexts from Apache Commons Collections (collections), Derby (derby), Hadoop (hadoop), Ivy (ivy) and Lucene (lucene) projects.
        <ol>
          <li>we selected a completely different set of projects for change resources from the projects in Defects4j dataset.</li>
          <li>For each context, there are averages 1.91 and 16.25 changes in PTLRH and PLRT change pools respectively</li>
        </ol>
      </li>
      <li>We built change pools and obtained coverage information of all buggy codes before we applied ConFix to each bug.
        <ol>
          <li>Change pool and coverage information is given to ConFix</li>
        </ol>
      </li>
    </ol>
  </li>
  <li>Results
    <ol>
      <li>Compilation of one Java file is much cheaper than test execution even if only a few failing test is executed. Therefore ConFix can find a patch within a reasonable time.</li>
      <li>Acceptable and Plausible</li>
      <li>We did not set a time budget, however, ConFix generated all the patches within two hours</li>
      <li>ConFix generated 71 patches
        <ol>
          <li>which are greater than other techniques - ssFix(60), Nopol(33), jGenProg(19), jKali(18), HDRepair(16) and ACS(7)</li>
          <li>generated 13 acceptable patches, which is significantly higher than valid patches generated by HDRepair(5), ACS(3), jGenProg(3), jKali(1), and Nopol(0). One exception is ssFix, which generated 20 valid patches, higher than ConFix.</li>
        </ol>
      </li>
      <li>ssFix
        <ol>
          <li>We verified ssFix-generated patches again and found that two valid patches (C1, M79) are not acceptable patches.</li>
        </ol>
      </li>
      <li>ConFix was able to find necessary changes and the right fix locations with its patch generation strategy</li>
      <li>Informative Patches
        <ol>
          <li>Although plausible patches are not acceptable when it is compared to human-written patches, they might be given as debugging hints for developers.</li>
          <li>we manually analyzed 58 plausible patches and checked whether these patches are informative.</li>
        </ol>
      </li>
    </ol>
  </li>
  <li>Are PLRTH and PLRT really helpful?
    <ol>
      <li>With PTLRH contexts, ConFix explores a much narrower area in its candidate space
        <ol>
          <li>Consequently, it might also lose the chance that actual patches are included in the area</li>
        </ol>
      </li>
      <li>Among 71 generated patches, 81% of the patches (58/71) are generated by changes from PTLRH change pools. In terms of acceptable patches, using PLRT context only gives two more acceptable patches, and PTLRH change pool still works for 85% of the acceptable patches (11/13).</li>
      <li>ConFix generated two acceptable patches which take 15% of all acceptable patches under both types of context. These PLRT acceptable patches are all semantically equivalent to human-written patches, which means that they addressed issues in the same way as humans did. Therefore PLRT context can also provide practical constraints to mimic the developer’s changes and produce acceptable patches.</li>
    </ol>
  </li>
  <li>Threats to validity
    <ol>
      <li>Our evaluation results might be different if we used other collected changes from different human-written patches.</li>
      <li>There exists another issue that bugs from five projects might not be representative</li>
      <li>Manual assessment of patches could be another issue, since we do not have domain knowledge and the judgment about patches might be subjective and biased.</li>
    </ol>
  </li>
  <li>Related Works
    <ol>
      <li>The difference is that ConFix uses AST contexts to select one of the changes, while ssFix considers the syntactic relation of code fragments to given buggy code.</li>
      <li>Identifying AST contexts is less costly than deriving SMT constraints, but these contexts still provide syntactic information which also implies some of the program semantics, although it does not fully represent the program’s semantics like SMT constraints.</li>
      <li>ConFix differs from these previous techniques due to the point that it can automatically collect abstract individual changes on a large scale and it uses them to generate patch candidates, instead of generating patch candidates with several pre-defined modifications or mutation operations with limited resources of code fragments</li>
    </ol>
  </li>
  <li>Studies on Human-written patches
    <ol>
      <li>changes in bug fixes are repetitive, and smaller changes are even more repetitive</li>
      <li>There exist other studies on changes and source code’s uniqueness which imply the potential of techniques leveraging 17 existing code fragments or changes</li>
      <li>Empirical evaluation of ConFix and fixability analysis results imply that we can obtain necessary changes for new bug fixes from existing patches.</li>
    </ol>
  </li>
  <li>Change Collection and Application
    <ol>
      <li>we may consider using these code transfer techniques to develop new methods for patch candidate generation in ConFix</li>
      <li>it is possible to apply high-level ideas such as collecting abstract changes with their AST contexts regardless of adjustment</li>
    </ol>
  </li>
  <li>Conclusion
    <ol>
      <li>We may try to generate patches with multiple changes to improve partial patches up to acceptable patches or use more sophisticated concretization methods to effectively generate high-quality patches.</li>
    </ol>
  </li>
</ol>

<h3 id="knowledge">Knowledge:</h3>

<ul>
  <li>Context-based Change Application Technique: a technique to generate candidate patches</li>
  <li>ConFix can expand its search space by collecting more changes, while it can navigate through them effectively with the guidance of context</li>
</ul>

<h3 id="terminology">Terminology:</h3>

<ul>
  <li>Hunk: Single changes including deletion and addition, may have multiple in a single commit</li>
</ul>

<h3 id="questions">Questions:</h3>

<ul>
  <li>Why PLRTH and PLRT: The paper mentioned it is for reducing the search space. Is it the most efficient way to do it?</li>
  <li>I don’t understand the part about fault localization. Is it possible to localize the fault using AST context? Does it just localize fault according to the collected change?</li>
  <li>What if AST differencing tools work maliciously?</li>
</ul>]]></content><author><name>JSC</name><email>newwin0198@handong.ac.kr</email></author><category term="APR" /><category term="APR" /><summary type="html"><![CDATA[ConFix]]></summary></entry><entry><title type="html">알고리즘 분석과 벚꽃</title><link href="http://localhost:4000/recent/Prof.Yong-Algorithm-Analysis/" rel="alternate" type="text/html" title="알고리즘 분석과 벚꽃" /><published>2023-06-09T00:00:00+09:00</published><updated>2023-06-09T00:00:00+09:00</updated><id>http://localhost:4000/recent/Prof.Yong-Algorithm-Analysis</id><content type="html" xml:base="http://localhost:4000/recent/Prof.Yong-Algorithm-Analysis/"><![CDATA[<p>거의 처음으로 한글로 블로그 포스팅을 써보는 것 같다! 
아무래도 한국어가 제일 편하긴하다 ㅎ <br /></p>

<p>블로그 포스팅을 학기 중에 하고자 헀지만 도저히 안되더라… 그래서 학기 중에 블로그 포스팅 할 것들 메모해놓고 방학 중에 일일히 쓰는 중이다! 날짜도 그 때 썼다고 생각하고 업로드 하는 중이기도 하고… ㅋㅋㅋ<br /></p>

<p>한동에서의 3학년이 사망년이 되지 않기를 바라는 포스트 이후 논문 리뷰나 책 리뷰 외의 글을 쓰는 것은 몇달 만인 것 같다. 원래 쓸 생각이 없었는데 포스팅 할 내용이 나에게 큰 위로가 되었기도 하고…</p>

<p>이번 블로그 글의 제목은 알고리즘 분석과 벚꽃이다! 무슨 관계가 있을까 싶겠지만 꽤나 깊은 관계(?)가 있다.</p>

<p>한동에는 중간고사 기간을 주위로 하여 벚꽃이 핀다! 벚꽃이 정말 아름답게 핀다. 내가 사진을 잘 안찍어서 벚꽃 사진이 없어서 첨부를 못하는게 아쉽다 ㅠㅠ 뭐 찾으면 있겠지만 귀찮기도 하고 사진을 왜 찍지 이해를 못하기도 하고… 뭐 암튼 그렇다. 거두절미하고 이 글은 알고리즘 분석 6월 9일 수업 때 일어난 일의 이야기를 담고 있다. 기억을 더듬어보자면 기말 고사를 앞둔 기간이었고, 과제는 미칠 듯이 쏟아져 나오고 있었다. 다들 너무 지쳐서 수업 분위기는 말이 아니었고 나도 굉장히 지쳐있었다.</p>

<p>수업분위기에 화를 몇 번 내시던 교수님께서 갑자기 벚꽃 이야기를 꺼내셨다. 학교 벚꽃이 이쁘다면서 벚꽃이랑 사진찍는 학생들을 매년 보고 있다는 이야기를 하셨다. 뒤이어 학생들이 벚꽃과 사진을 찍는 것을 이해하지 못한다고 하셨다. 내심 나랑 공감하는 사람이 있다는 생각이 드는 찰나 교수님은 갑자기 닭살돋는 이야기를 하셨다. <em>“이 아이들은 자신이 벚꽃보다 아름답다는 걸 모르나? 왜 사진을 찍지?”</em> 많이 놀랐랐다. <del>알고리즘 분석 담당 교수님께서 무섭기로 유명하시다…</del></p>

<p>그렇게 말씀하시면서 여러 말을 덧붙이셨다. 사람이 가장 아름다운 나이는 20대 초중반이라고. 우리가 지금 20대 초중반을 지나고 있기에 우리가 하는 일들은 모두 아름답고 가치 있는 일이라고. 반대로 이렇게 꽃다운 나이기에 치열하게 살아가고, 후회없이 모든 것을 쏟아낼 수 있는 나이라고.</p>

<p>솔직히 많은 위로가 됐다. 내가 글을 쓰는 재주도 없고 한 달 정도가 지난 후에 글을 쓰는 만큼 글에 감동이 하나도 묻어있지 않는게 너무 아쉽다…</p>

<p>이제는 젊다고 할 수 없는 나이에 접어들었지만 치열하게 살아가야 한다는 사실은 오히려 나이가 들수록 깨닫고 있는 것 같다. 나이가 들고 후회하기 보다는 노력해보고 후회하는게 나쁘지 않은 것 같다 ㅎㅎ 교수님 감사합니다!</p>]]></content><author><name>JSC</name><email>newwin0198@handong.ac.kr</email></author><category term="Blog" /><category term="Blog" /><summary type="html"><![CDATA[젊음!]]></summary></entry></feed>