<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2023-07-14T18:11:22+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">JSC’s DevLog</title><subtitle>SE and AI version 1.0</subtitle><author><name>JSC</name><email>newwin0198@handong.ac.kr</email></author><entry><title type="html">Can We Automatically Fix Bugs by Learning Edit Operations?</title><link href="http://localhost:4000/recent/Can-We-Automatically-Fix-Bugs-by-Learning-Edit-Operations/" rel="alternate" type="text/html" title="Can We Automatically Fix Bugs by Learning Edit Operations?" /><published>2023-07-13T00:00:00+09:00</published><updated>2023-07-13T00:00:00+09:00</updated><id>http://localhost:4000/recent/Can%20We%20Automatically%20Fix%20Bugs%20by%20Learning%20Edit%20Operations</id><content type="html" xml:base="http://localhost:4000/recent/Can-We-Automatically-Fix-Bugs-by-Learning-Edit-Operations/"><![CDATA[<h2 id="can-we-automatically-fix-bugs-by-learning-edit-operations">“Can We Automatically Fix Bugs by Learning Edit Operations?”</h2>

<h2 id="paper"><a href="https://www.cs.wm.edu/~denys/pubs/SANER-RENE-BugFixing.pdf">Paper</a></h2>

<h3 id="summary">Summary:</h3>

<ul>
  <li>
    <p>Implementing Hephaestus, a novel method to improve the accuracy of APR through learning to apply edit operations. Leverages neural machine translation and attempts to produce the edit operations needed.</p>

    <p>Learning edit operations does not offer an advantage over the standard approach of translating directly from buggy code to fixed code. However, interestingly, Hephaestus exhibited lower translation accuracy than the baseline, able to perform successful bug repair.</p>
  </li>
</ul>

<h3 id="points">Points:</h3>

<ol>
  <li>Introduction
    <ol>
      <li>The naive approach attempts some sort of comparison algorithm that identifies the type of bug and replaces it with a prescribed bugs
        <ol>
          <li>Time Consuming</li>
        </ol>
      </li>
      <li>Learning approach using neural machine translation</li>
      <li>Directly applying the NMT approach to source code is inefficient
        <ol>
          <li>Many bugs fixes involve changes to a few sentences
            <ol>
              <li>Results in suboptimal performances</li>
            </ol>
          </li>
          <li>Attempt to mitigate the inefficiency by predicting the specific statement on AST</li>
          <li>Attempting on individual tokens would be more optimal</li>
        </ol>
      </li>
      <li>Hephaestus leverages NMT to predict edit operation, derived from Levenshtein Distance Algorithm
        <ol>
          <li>Working at the token level of source code</li>
          <li>Work on any language without language-specific parsers</li>
        </ol>
      </li>
    </ol>
  </li>
  <li>Related Works
    <ol>
      <li>Tufano et al.
        <ol>
          <li>Repairing code through identification of bug-fix patterns in large software repositories</li>
          <li>Usage of Deep Learning Approach regarding “meaningful” change</li>
        </ol>
      </li>
      <li>Chen et al.
        <ol>
          <li>Focus on single-line bug</li>
        </ol>
      </li>
      <li>Jiang et al.
        <ol>
          <li>The correct fix for a given bug does not exist within the model’s output space and the model’s lack of awareness of syntax</li>
          <li>Pre-train model on the programming language in question</li>
        </ol>
      </li>
      <li>Yuan and Banzhaf
        <ol>
          <li>grouping fine-granularity edits into larger statement-level edits</li>
        </ol>
      </li>
      <li>Mousavi et al.
        <ol>
          <li>Overfitting and Disparity between predicted bug and fix operation and would mimic a human software developer</li>
        </ol>
      </li>
    </ol>
  </li>
  <li>Background
    <ol>
      <li>Fixing buggy code to fixed code using traditional language translation matter of the buggy to fix a variety of language</li>
      <li>Traditional translation replaces the majority of the input sequence which is natural language.
        <ol>
          <li>Fix in code might be minimal</li>
          <li>repair translation should not have the same meaning as the input</li>
        </ol>
      </li>
    </ol>
  </li>
  <li>Approach
    <ol>
      <li>Levenshtein Edit Operation
        <ol>
          <li>the bug is input sequence, the NMT model attempts to produce edit operations</li>
          <li>Basic Operations
            <ol>
              <li>Insertion</li>
              <li>Deletion</li>
              <li>Replacement</li>
            </ol>
          </li>
        </ol>
      </li>
      <li>Compound Edit Operations
        <ol>
          <li>Group of one or more edit operations; sequence of operations</li>
          <li>Condensing: A grouping process to compound operations</li>
        </ol>
      </li>
      <li>Dataset Construction
        <ol>
          <li>Control Dataset: baseline, not involved with edit operations</li>
          <li>Machine String: In order to include edit operations, transforming edit operations
            <ol>
              <li>Typed</li>
              <li>General</li>
            </ol>
          </li>
          <li>We make the distinction between typed and general form to determine if the form of machine string used during training affects the Hephaestus models’ abilities to learn edit operations.</li>
        </ol>
      </li>
      <li>Experimental Dataset
        <ol>
          <li>translate the bug into its corresponding fix, showing Levenshetein edit distance between the bug and fix</li>
          <li>all basic compound operation sequences which transform the bug into the fix, strict is the minimal sequence of the strict compound operation sequences, and loose is the minimal sequence of the loose compound operation sequences</li>
        </ol>
      </li>
      <li>Model Construction
        <ol>
          <li>LSTM+General</li>
          <li>GRU+General</li>
          <li>LSTM+Typed</li>
        </ol>
      </li>
      <li>The CEC ensures that error signals fed forward into the LSTM layers and backpropagated to the LSTM layers are resistant to the effects of the vanishing gradient problem.</li>
    </ol>
  </li>
  <li>Experimental Design
    <ol>
      <li>Perfect Prediction Accuracy</li>
      <li>Failed Prediction Rate</li>
      <li>Edit Distance Decrease</li>
      <li>Training Accuracy</li>
    </ol>
  </li>
  <li>Result
    <ol>
      <li>PPA: The control model (baseline model) outperformed the rest, with no much difference</li>
      <li>FPR: The control model maintained 100% capability, the string can always be interpreted as a sequence of Java method tokens</li>
      <li>EDD: every model generates “bug fixes” that were further away from the fixed code than the original buggy code</li>
      <li>Training Accuracy: Every model exceeded 90%</li>
    </ol>
  </li>
  <li>RQ
    <ol>
      <li>RQ1: Is learning edit operations an effective approach to automatic bug repair?
        <ol>
          <li>learning edit operations does not offer advantages over the baseline approach. The experimental Hephaestus models must determine a sequence of edit operations, decode them, and apply them to the inputted buggy method in order to predict fixed source code</li>
        </ol>
      </li>
      <li>RQ2: What effect does each condensing strategy and machine string form have on the accuracy of bug repair?
        <ol>
          <li>The differences in PPA between the basic, strict, and loose models are negligible, but there are differences according to the training accuracy and average EDD values. Despite having significantly lower final training accuracy, the strict and loose models had slightly more positive EDD values than the basic models (a difference of about 0.96). Thus, it is evidenced that condensing edit operations into strict and loose forms are beneficial over not condensing them at all</li>
        </ol>
      </li>
      <li>RQ3: What is the effect of using an LSTM-based architecture versus a GRU-based architecture on the accuracy of bug repair?
        <ol>
          <li>the variation is not meaningful enough to consider as a key difference between the models.</li>
        </ol>
      </li>
      <li>Future Work
        <ol>
          <li>It was determined that most failed predictions were caused by generated indices outside the valid range for a given string. What changes can be made to this model to restrict the prediction range?</li>
          <li>does changing the abstraction method of the training dataset affect this metric?</li>
          <li>Other NLP Tools</li>
          <li>Extra software layers in addition to the methods presented in our study.</li>
        </ol>
      </li>
      <li>Conclusion
        <ol>
          <li>The introduction of these specific methods for training NMTbased systems to learn bug fixes did not provide a benefit to the task</li>
          <li>Edit operations are capable of performing automated bug repair to some degree</li>
        </ol>
      </li>
    </ol>
  </li>
</ol>

<h3 id="knowledge">Knowledge:</h3>

<ul>
  <li>NMT (Neural Machine Translation): <a href="https://en.wikipedia.org/wiki/Neural_machine_translation">Neural machine translation - Wikipedia</a>uses an artificial neural work to predict the likelihood of a sequence of words</li>
  <li>Levenshtein Distance Algorithm: A string metric for measuring the difference between two sequences. This is likely due to the experimental models experiencing higher entropy than the control when making predictions.</li>
</ul>

<h3 id="terminology">Terminology:</h3>

<ul>
  <li>Condensing Strategies:
    <ul>
      <li>Basic Condensing: basic compound operation corresponds with exactly one change</li>
      <li>Loose Condensing: iff the application of its constituent operation is equivalent to the application of some singular op
        <ul>
          <li>Modify a contiguous section of tokens</li>
        </ul>
      </li>
      <li>Strict Condensing: iff it is loosely compatible and every operation is of the same flavor</li>
    </ul>
  </li>
  <li>Machine Strings:
    <ul>
      <li>Typed: f is one of ins, del, or rep, depending on if the flavor of the represented edit operation is insertion, deletion, or replacement, respectively</li>
      <li>General: general form machine strings do not explicitly store the flavor of their represented edit operations</li>
    </ul>
  </li>
</ul>

<h3 id="tool">Tool:</h3>

<p><a href="https://github.com/WM-SEMERU/hephaestus">GitHub - WM-SEMERU/hephaestus</a></p>

<h3 id="questions">Questions:</h3>]]></content><author><name>JSC</name><email>newwin0198@handong.ac.kr</email></author><category term="APR" /><category term="APR" /><summary type="html"><![CDATA[Generalizing the change is helpful...?]]></summary></entry><entry><title type="html">Clean Code Chapter 2</title><link href="http://localhost:4000/recent/Clean_Code_Ch2/" rel="alternate" type="text/html" title="Clean Code Chapter 2" /><published>2023-07-13T00:00:00+09:00</published><updated>2023-07-13T00:00:00+09:00</updated><id>http://localhost:4000/recent/Clean_Code_Ch2</id><content type="html" xml:base="http://localhost:4000/recent/Clean_Code_Ch2/"><![CDATA[<p><strong>Using the appropriate Name will pay off in the short term and continue to pay in the long run</strong></p>

<ul>
  <li>Using Intention-Revealing Names
    <ul>
      <li>Choosing good names takes time but saves more than it takes</li>
      <li>Choosing a name that specifies what is being measured and the unit of that measurement</li>
      <li>Things need to think
        <ul>
          <li>What kind are in</li>
          <li>What is returned</li>
          <li>zeroth subscript and value</li>
        </ul>
      </li>
      <li>Do not use <strong>O <em>and l</em></strong></li>
    </ul>
  </li>
  <li>Avoid Disinformation
    <ul>
      <li>Avoiding words whose entrenched meanings vary from intention</li>
      <li>Spelling similar concepts similarly
        <ul>
          <li>No inconsistent spelling</li>
        </ul>
      </li>
      <li><del>Using different font??</del></li>
    </ul>
  </li>
  <li>Meaningful Distinction
    <ul>
      <li><strong>a</strong> for a local variable, <strong>the</strong> for all function arguments</li>
      <li>Less redundant words</li>
      <li>Distinguishing names in a way that readers know what the difference offer</li>
    </ul>
  </li>
  <li>Using Pronounceable Names
    <ul>
      <li>Essential for communication</li>
    </ul>
  </li>
  <li>Using Searchable Names
    <ul>
      <li>Single-letter names can ONLY be used as local variables inside short methods</li>
      <li>The length of a name should correspond to the size of its scope</li>
    </ul>
  </li>
  <li>Avoiding Encoding</li>
  <li>Hungarian Notation
    <ul>
      <li>The compiler knows the type nowadays</li>
    </ul>
  </li>
  <li>Member Prefixes
    <ul>
      <li>unseen clutter and a marker of older code…</li>
    </ul>
  </li>
  <li>Interface and Implementation
    <ul>
      <li>Why would I let user knows I’m handling them with an interface?</li>
      <li>Marking at the implementation</li>
    </ul>
  </li>
  <li>Avoid Mental Mapping
    <ul>
      <li>In most contexts, a single letter for a loop is a poor choice (such as i, j, k)</li>
      <li><em>Clarity is king</em></li>
    </ul>
  </li>
  <li>Class Names
    <ul>
      <li>should have noun or noun phrase names</li>
    </ul>
  </li>
  <li>Method Names
    <ul>
      <li>should have verb or verb phase names</li>
      <li>When constructors are overloaded, use the static method with names that describe the argument
        <ul>
          <li>Make corresponding constructors private</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>Don’t be cute
    <ul>
      <li>No too “user-specific name”</li>
    </ul>
  </li>
  <li>Pick One Word per Concept
    <ul>
      <li>Pick one word for one abstract concept</li>
      <li>The name will express two different types of object</li>
    </ul>
  </li>
  <li>Don’t Pun
    <ul>
      <li>Avoiding using the same word for two purposes</li>
      <li>Even if it has a similar concept, it must have a different name if it is semantically different</li>
      <li><strong><em>It is the author’s responsibility</em></strong></li>
    </ul>
  </li>
  <li>Use Solution Domain Names
    <ul>
      <li>People who read your code will be programmers
        <ul>
          <li>CS terms, algorithm names, pattern names, math terms, etc.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>Use Problem Domain Names
    <ul>
      <li>Separating solution and problem domain concept</li>
    </ul>
  </li>
  <li>Add Meaningful Context
    <ul>
      <li>Place the name in context for the reader
        <ul>
          <li>enclosing classes, functions, or namespaces</li>
        </ul>
      </li>
      <li>break it into smaller functions if it is necessary</li>
    </ul>
  </li>
  <li>But Don’t Add Gratuitous Context
    <ul>
      <li>Shorter names are generally better
        <ul>
          <li>As long as they are clear</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>]]></content><author><name>JSC</name><email>newwin0198@handong.ac.kr</email></author><category term="Books" /><category term="Blog" /><summary type="html"><![CDATA[How to name clearly]]></summary></entry><entry><title type="html">Clean Code Chapter 1</title><link href="http://localhost:4000/recent/Clean_Code_Ch1/" rel="alternate" type="text/html" title="Clean Code Chapter 1" /><published>2023-07-13T00:00:00+09:00</published><updated>2023-07-13T00:00:00+09:00</updated><id>http://localhost:4000/recent/Clean_Code_Ch1</id><content type="html" xml:base="http://localhost:4000/recent/Clean_Code_Ch1/"><![CDATA[<ul>
  <li>What is Clean Code?
    <ul>
      <li>Bjarne Stroustrup, Inventor of C++
        <ul>
          <li>Wasted Cycle are inelegant, not pleasing</li>
          <li>Error handling should be complete</li>
          <li>Focused; Each function, class, and module expose a single-minded attitude that remains entirely undistracted, and unpolluted, by the surrounding details</li>
        </ul>
      </li>
      <li>Grady Booch, author of Object Oriented Analysis and Design with Application
        <ul>
          <li>He took a readability perspective</li>
          <li>Well-written purpose</li>
          <li>clean code should clearly expose the tensions in the problem to be solved</li>
          <li>Should be matter-of-fact as opposed to speculative</li>
        </ul>
      </li>
      <li>Dave Thomas, founder of OTI
        <ul>
          <li>Make it easy for other people to enhance it</li>
          <li>Code without test is not clean at all</li>
          <li>values code that is small, code should be literate</li>
        </ul>
      </li>
      <li>Michael Feathers, author of Working Effectively with Legacy Code
        <ul>
          <li>Looks like it was written by someone who cares</li>
          <li>Someone has taken the time to keep it simple and orderly</li>
        </ul>
      </li>
      <li>Ron Jeffries, author of Extreme Programming Installed and Extreme Programming Adventures in C#
        <ul>
          <li>No duplications</li>
          <li>Express all the design ideas
            <ul>
              <li>High expressiveness</li>
            </ul>
          </li>
          <li>Minimize the number of entities
            <ul>
              <li>Find things in a collection</li>
              <li>Wrap particular implementation in a more abstract method</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>Ward Cunningham, inventor of Wiki, inventor of Fit …
        <ul>
          <li>read turns out what you expected</li>
          <li>make it look like the language was made for the problem</li>
          <li>It is the programmer that makes the language appear simple</li>
        </ul>
      </li>
      <li>Author: <a href="https://www.google.com/search?q=Robert+C.+Martin&amp;stick=H4sIAAAAAAAAAONgVuLWz9U3MDSqMspOT3rEaMYt8PLHPWEp3UlrTl5jVOfiCs7IL3fNK8ksqRSS5GKDsvileLmQ9fEsYhUIyk9KLSpRcNZT8E0sKsnMAwD4hk_pWwAAAA&amp;sa=X&amp;ved=2ahUKEwjDuvb5qYSAAxWJAt4KHYeWALQQzIcDKAB6BAgiEAE">Robert Cecil Martin</a>
        <ul>
          <li>Discovering new techniques and founding their own schools</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p>Many Recommendations in this book are controversial.</p>

<p>And we are <strong>AUTHORS</strong>.</p>

<ul>
  <li>Making it Easy to read makes it easier to write</li>
  <li>The code has to be kept clean over time</li>
</ul>

<p>This book cannot promise to make you a good programmer.</p>

<p><strong>“Practice, son. Practice!”</strong></p>]]></content><author><name>JSC</name><email>newwin0198@handong.ac.kr</email></author><category term="Books" /><category term="Blog" /><summary type="html"><![CDATA[What is Clean Code?]]></summary></entry><entry><title type="html">Automatic Patch Generation with Context-based Change Application</title><link href="http://localhost:4000/recent/ConFix/" rel="alternate" type="text/html" title="Automatic Patch Generation with Context-based Change Application" /><published>2023-07-10T00:00:00+09:00</published><updated>2023-07-10T00:00:00+09:00</updated><id>http://localhost:4000/recent/ConFix</id><content type="html" xml:base="http://localhost:4000/recent/ConFix/"><![CDATA[<h3 id="automatic-patch-generation-with-context-based-change-application">Automatic Patch Generation with Context-based Change Application</h3>

<h2 id="paper"><a href="https://raw.githubusercontent.com/wiki/thwak/ConFix/pre-print.pdf">Paper</a></h2>

<p>Jindae Kim, Sunghun Kim</p>

<h3 id="goal">Goal:</h3>

<ol>
  <li>I am collecting changes from human-written patches for new patch candidate generation.</li>
  <li>Automatic patch generation technique leveraging human-written patches with our context-based change application technique used by ConFix.</li>
</ol>

<h3 id="summary">Summary:</h3>

<ul>
  <li>An effective patch generation technique should have a large search space with a high probability that patches for bugs are included, and it also needs to locate such patches effectively. Confix collects abstract AST changes from human-written patches, providing resources for patch generation. Then, using only matching context only, Confix selects a necessary change for a possible fixed location. Also, Confix filters out undesirable locations to fix using the info that the location has not been changed in human-written patches.</li>
</ul>

<h3 id="points">Points:</h3>

<ol>
  <li>The problem with APR is search space size and navigation.
    <ol>
      <li>To solve the problem, mining changes from human-written patches has been trying, but it makes navigation for the patch more difficult since the changes are very sparse.</li>
      <li>Confix, use context-based change application technique to generate patch candidates.
        <ol>
          <li>AST context applies collected change to a possible fixed location only if their AST contents are matched</li>
          <li>ConFix compares AST contexts defined by parent, left, and right nodes of a change and a location and applies the change to a target location only if their contexts are matched.</li>
        </ol>
      </li>
    </ol>
  </li>
  <li>Change Collection
    <ol>
      <li>Collecting changes generally applicable to other location</li>
      <li>We extract AST form since source code can be easily affected by specific user styles.</li>
      <li>Following some steps, dependent on how changes are collected</li>
    </ol>
  </li>
  <li>Change Extraction
    <ol>
      <li>Each hunk is extracted and converted to an individual AST subtree change.</li>
      <li>Collect separate individual changes rather than the whole patch to use repetitiveness of changes.</li>
      <li>To extract changes, use the differencing tool, generates AST subtree edit operation, combine node edit operation into trees
        <ol>
          <li>AST node type and node value indicate a specific identifier, literals, or operators; the edit operation preserves the AST structure of the inserted code fragment</li>
        </ol>
      </li>
    </ol>
  </li>
  <li>Change conversion
    <ol>
      <li>Extracted edit operations need to be independent and applicable form.
        <ol>
          <li>The type needs to be changed as a single change
            <ol>
              <li>divide operation more</li>
              <li>extends operation</li>
              <li>remove any operation if a changed AST is a subtree of another operation’s changed AST</li>
              <li>Find all inserted-delete pairs applied to the same location and combine them.</li>
            </ol>
          </li>
        </ol>
      </li>
      <li>Need to normalize the user-defined identifiers.
        <ol>
          <li>By normalizing user-defined names, we can increase the reusability of collected changes since we can apply a change regardless of the availability of user-defined names.</li>
          <li>The technique normalizes user-defined names with two principles: consistency and order-preserving</li>
          <li>By normalizing user-defined names, we can increase the reusability of collected changes since we can apply a change regardless of the availability of user-defined names.</li>
          <li>At the time of change concretization, the collected information works as requirements for each abstract name which ConFix should consider when it assigns a concrete name for the abstract name.</li>
        </ol>
      </li>
      <li>Change Context Identification
        <ol>
          <li>After individual changes are obtained from source code patches, the next step is identifying the AST contexts of the changes.</li>
          <li>By identifying the context of the target location, we can avoid meaningless modifications and more frequent changes.</li>
          <li>To define AST context, use nearby nodes of a changed AST subtree
            <ol>
              <li>The parent node represents the location where a changed code fragment belongs.</li>
              <li>The left and Right nodes indicate code fragments before and after the changed code fragment.</li>
              <li>Using fingerprinting technique</li>
              <li>Dyck Word Hash
                <ol>
                  <li>represents the parent-child relationship of nodes</li>
                  <li>Compare two nodes’ hash values to check whether they are the roots of two type-isomorphic AST subtrees.</li>
                  <li>For fast comparison</li>
                </ol>
              </li>
            </ol>
          </li>
          <li>PLRTH and PLRT
            <ol>
              <li>left node indicates code before the changed code frame; the right node indicates code after the changed code fragment</li>
              <li>PTLRH context, we also examine whether the change and the location have the same code fragment before and after them, while PLRT context only checks which kind of code fragments exist before and after the change and the location.</li>
              <li>PTLRH context constrains the search area too much; we can expand the search area with PLRT context.</li>
              <li>Exception</li>
              <li>Block node does not mean too much; use its parent node as a type.</li>
              <li>Move operations primarily consider the old location’s context, but store the new location’s context to use it as an additional constraint of move changes.</li>
            </ol>
          </li>
        </ol>
      </li>
    </ol>
  </li>
  <li>Change Application
    <ol>
      <li>Target Location Context Identification
        <ol>
          <li>The target location is also an AST node to which a change will be applied</li>
          <li>To identify the location context is compatible with change contexts, using PLR nodes we can identify location contexts for changes
            <ol>
              <li>Except for insert, another operation has an old AST subtree so it is applicable</li>
              <li>The inserted context is identified from New AST which is inserted. We need a different type, based on the assumption that a subtree is inserted near a location. Insert Before and Insert After contexts are the contexts for cases in which a new AST subtree is inserted before and after node N. Node C indicates the actual location where a subtree will be inserted</li>
            </ol>
          </li>
        </ol>
      </li>
    </ol>
  </li>
  <li>Change Selection
    <ol>
      <li>retrieve changes with the same context from a changing pool</li>
      <li>Categorized by their context, only store unique changes with their frequency</li>
      <li>choose one of the selections and mimic human-written changes by selecting any of the changes on the list
        <ol>
          <li>The random selection, strategy is not decided specifically</li>
        </ol>
      </li>
    </ol>
  </li>
  <li>Change Concretiziation
    <ol>
      <li>Replacing all normalized identifiers with concrete name
        <ol>
          <li>Do not fully specify the strategy yet how ConFix concretizes a change since various strategies can be used</li>
          <li>Since the type of normalized variables and signature of normalized methods are also stored during change collection, we can consider a strategy that assigns an existing variable name to a normalized variable (if the type is compatible)</li>
          <li>Since change is concretized, apply it to the target location</li>
        </ol>
      </li>
    </ol>
  </li>
  <li>Patch generation
    <ol>
      <li>Generate-and-validate process</li>
      <li>Starts with the PTLRH pool to narrow down the search area for patch generation, switch to PLRT if the patch generation failed at the above level</li>
      <li>Identify target location, retrieves changes having the same context as the selected location, apply it to the target location</li>
      <li>Lastly, tries different name assignments by predefined max trials
        <ol>
          <li>To prevent spoiled validation due to wrong name assignment</li>
        </ol>
      </li>
      <li>Pass -&gt; termination; Fail -&gt; continues with another change</li>
      <li>When it reaches the max candidate, moves to the next change pool</li>
    </ol>
  </li>
  <li>Target Location Identification
    <ol>
      <li>Confix leverages both fault localization and change context to identify target locations from given buggy code
        <ol>
          <li>Identifies all AST nodes which belong to the statement as potential target locations</li>
          <li>filters out all target locations having context not included in the current change pool</li>
          <li>Identify fail and pass a group
            <ol>
              <li>The first pick from the fail-only group, if there is no location, starts from the pass-fail group</li>
              <li>Failing test cases have a much higher priority</li>
            </ol>
          </li>
          <li>Prior target location has if, method invocation, infix expression, or return statement since it influences the whole execution</li>
        </ol>
      </li>
    </ol>
  </li>
  <li>Change Selection
    <ol>
      <li>ConFix selects one of the retrieved changes for the current target location and chooses the most frequent change</li>
      <li>Even if it is in the same context, change might not be applicable
        <ol>
          <li>In case of replacement operation, one more location should be selected</li>
          <li>Therefore, ConFix randomly selects one of the target locations with a matching context
            <ol>
              <li>If there is not, discard the change</li>
            </ol>
          </li>
        </ol>
      </li>
      <li>Code might not be compilable, so ConFix goes through the verification steps
        <ol>
          <li>Examine all change-location pairs since a change that was applicable in another location might not be applicable in other locations</li>
          <li>Considering all pairs and compiling is beneficial rather than since it is not expensive to recompile source code with a small modification</li>
        </ol>
      </li>
    </ol>
  </li>
  <li>Change Concretization
    <ol>
      <li>Concretizing selected change for the target location</li>
      <li>ConFix collects concrete names of variables, types, and methods from the given buggy code and decides which names are within the scope</li>
      <li>To find a concrete method for a normalized method, ConFix identifies compatible methods from collected methods available at a target location</li>
      <li>Abstract signature
        <ol>
          <li>method signature with normalized types</li>
          <li>The purpose of this is to find a concrete method with the same abstract signature, then it will not cause a compile error</li>
        </ol>
      </li>
      <li>Assignable type
        <ol>
          <li>Consider both type compatibility and the number of variables of the types
            <ol>
              <li>Normalized types are considered wildcard characters, which means that they can be assignable to either normalized types or JSL types.</li>
              <li>ConFix only considers a type as assignable to another type if there exist enough variables for assignment.</li>
            </ol>
          </li>
          <li>the compatibility of a normalized and a concrete method is defined by their abstract signatures and assignable types
            <ol>
              <li>The concrete method first considers local methods, then global methods with the assumption that local methods are more closely related to buggy code</li>
              <li>Once a concrete method for a normalized method is selected and assigned, ConFix update types are matched due to method assignment</li>
              <li>Randomly assigns one of the assignable concrete types for each normalized type</li>
              <li>Assigns concrete variables to normalized variables</li>
            </ol>
          </li>
          <li>There is one additional treatment for update type changes which updates an identifier with another identifier
            <ol>
              <li>Assume the update change is meaningful when the new name is similar to the old one, so calculate the Levenshtein distance between the identifier and concrete name</li>
            </ol>
          </li>
          <li>In case of no type-compatible assignment
            <ol>
              <li>Change concretization is considered failed and no patch candidate is generated</li>
            </ol>
          </li>
        </ol>
      </li>
    </ol>
  </li>
  <li>Evaluation
    <ol>
      <li>Collected changes with PTLRH and PTLR contexts from Apache Commons Collections (collections), Derby (derby), Hadoop (hadoop), Ivy (ivy) and Lucene (lucene) projects.
        <ol>
          <li>we selected a completely different set of projects for change resources from the projects in Defects4j dataset.</li>
          <li>For each context, there are averages 1.91 and 16.25 changes in PTLRH and PLRT change pools respectively</li>
        </ol>
      </li>
      <li>We built change pools and obtained coverage information of all buggy codes before we applied ConFix to each bug.
        <ol>
          <li>Change pool and coverage information is given to ConFix</li>
        </ol>
      </li>
    </ol>
  </li>
  <li>Results
    <ol>
      <li>Compilation of one Java file is much cheaper than test execution even if only a few failing test is executed. Therefore ConFix can find a patch within a reasonable time.</li>
      <li>Acceptable and Plausible</li>
      <li>We did not set a time budget, however, ConFix generated all the patches within two hours</li>
      <li>ConFix generated 71 patches
        <ol>
          <li>which are greater than other techniques - ssFix(60), Nopol(33), jGenProg(19), jKali(18), HDRepair(16) and ACS(7)</li>
          <li>generated 13 acceptable patches, which is significantly higher than valid patches generated by HDRepair(5), ACS(3), jGenProg(3), jKali(1), and Nopol(0). One exception is ssFix, which generated 20 valid patches, higher than ConFix.</li>
        </ol>
      </li>
      <li>ssFix
        <ol>
          <li>We verified ssFix-generated patches again and found that two valid patches (C1, M79) are not acceptable patches.</li>
        </ol>
      </li>
      <li>ConFix was able to find necessary changes and the right fix locations with its patch generation strategy</li>
      <li>Informative Patches
        <ol>
          <li>Although plausible patches are not acceptable when it is compared to human-written patches, they might be given as debugging hints for developers.</li>
          <li>we manually analyzed 58 plausible patches and checked whether these patches are informative.</li>
        </ol>
      </li>
    </ol>
  </li>
  <li>Are PLRTH and PLRT really helpful?
    <ol>
      <li>With PTLRH contexts, ConFix explores a much narrower area in its candidate space
        <ol>
          <li>Consequently, it might also lose the chance that actual patches are included in the area</li>
        </ol>
      </li>
      <li>Among 71 generated patches, 81% of the patches (58/71) are generated by changes from PTLRH change pools. In terms of acceptable patches, using PLRT context only gives two more acceptable patches, and PTLRH change pool still works for 85% of the acceptable patches (11/13).</li>
      <li>ConFix generated two acceptable patches which take 15% of all acceptable patches under both types of context. These PLRT acceptable patches are all semantically equivalent to human-written patches, which means that they addressed issues in the same way as humans did. Therefore PLRT context can also provide practical constraints to mimic the developer’s changes and produce acceptable patches.</li>
    </ol>
  </li>
  <li>Threats to validity
    <ol>
      <li>Our evaluation results might be different if we used other collected changes from different human-written patches.</li>
      <li>There exists another issue that bugs from five projects might not be representative</li>
      <li>Manual assessment of patches could be another issue, since we do not have domain knowledge and the judgment about patches might be subjective and biased.</li>
    </ol>
  </li>
  <li>Related Works
    <ol>
      <li>The difference is that ConFix uses AST contexts to select one of the changes, while ssFix considers the syntactic relation of code fragments to given buggy code.</li>
      <li>Identifying AST contexts is less costly than deriving SMT constraints, but these contexts still provide syntactic information which also implies some of the program semantics, although it does not fully represent the program’s semantics like SMT constraints.</li>
      <li>ConFix differs from these previous techniques due to the point that it can automatically collect abstract individual changes on a large scale and it uses them to generate patch candidates, instead of generating patch candidates with several pre-defined modifications or mutation operations with limited resources of code fragments</li>
    </ol>
  </li>
  <li>Studies on Human-written patches
    <ol>
      <li>changes in bug fixes are repetitive, and smaller changes are even more repetitive</li>
      <li>There exist other studies on changes and source code’s uniqueness which imply the potential of techniques leveraging 17 existing code fragments or changes</li>
      <li>Empirical evaluation of ConFix and fixability analysis results imply that we can obtain necessary changes for new bug fixes from existing patches.</li>
    </ol>
  </li>
  <li>Change Collection and Application
    <ol>
      <li>we may consider using these code transfer techniques to develop new methods for patch candidate generation in ConFix</li>
      <li>it is possible to apply high-level ideas such as collecting abstract changes with their AST contexts regardless of adjustment</li>
    </ol>
  </li>
  <li>Conclusion
    <ol>
      <li>We may try to generate patches with multiple changes to improve partial patches up to acceptable patches or use more sophisticated concretization methods to effectively generate high-quality patches.</li>
    </ol>
  </li>
</ol>

<h3 id="knowledge">Knowledge:</h3>

<ul>
  <li>Context-based Change Application Technique: a technique to generate candidate patches</li>
  <li>ConFix can expand its search space by collecting more changes, while it can navigate through them effectively with the guidance of context</li>
</ul>

<h3 id="terminology">Terminology:</h3>

<ul>
  <li>Hunk: Single changes including deletion and addition, may have multiple in a single commit</li>
</ul>

<h3 id="questions">Questions:</h3>

<ul>
  <li>Why PLRTH and PLRT: The paper mentioned it is for reducing the search space. Is it the most efficient way to do it?</li>
  <li>I don’t understand the part about fault localization. Is it possible to localize the fault using AST context? Does it just localize fault according to the collected change?</li>
  <li>What if AST differencing tools work maliciously?</li>
</ul>]]></content><author><name>JSC</name><email>newwin0198@handong.ac.kr</email></author><category term="APR" /><category term="APR" /><summary type="html"><![CDATA[ConFix]]></summary></entry><entry><title type="html">Operating Systems: Three Easy Pieces Ch. 37</title><link href="http://localhost:4000/recent/Chapter-38/" rel="alternate" type="text/html" title="Operating Systems: Three Easy Pieces Ch. 37" /><published>2023-06-17T00:00:00+09:00</published><updated>2023-06-17T00:00:00+09:00</updated><id>http://localhost:4000/recent/Chapter-38</id><content type="html" xml:base="http://localhost:4000/recent/Chapter-38/"><![CDATA[<p>Hard Disk Drives</p>

<ul>
  <li>the main form of persistent data storage</li>
  <li>The interface
    <ul>
      <li>Consist of a large number of sectors (512 - bytes block)</li>
      <li>Multi-sector operation
        <ul>
          <li>Updating the disk is atomic</li>
          <li>it will either complete in its entirety or it won’t complete at all</li>
          <li>torn write</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>Basic Geometry
    <ul>
      <li>Platter
        <ul>
          <li>Circular hard surface</li>
          <li>Each Platter has 2 surfaces</li>
        </ul>
      </li>
      <li>Spindle
        <ul>
          <li>Connected to motor</li>
          <li>RPM (rotations per minute)
            <ul>
              <li>7200 ~ 15000 RPM</li>
            </ul>
          </li>
          <li>Data is encoded on each surface in <strong>concrete circle</strong>
            <ul>
              <li>Track</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>Reading and writing is accomplished by the disk head
        <ul>
          <li>Disk head is attached to disk arm</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>Latency
    <ul>
      <li>Single-track Latency
        <ul>
          <li>Rotational Delay
            <ul>
              <li>it must just wait for the desired sector to rotate under the disk head</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>Multiple Tracks
        <ul>
          <li>Seek Time
            <ul>
              <li>Seek: Move disk arm to correct track</li>
              <li>Acceleration → disk arm gets moving</li>
              <li>Coasting → arm moving as full speed</li>
              <li>Deceleration → arm moves slow down</li>
              <li>Settling → head is carefully positioned
                <ul>
                  <li>settling time is significant</li>
                </ul>
              </li>
            </ul>
          </li>
          <li>Transfer
            <ul>
              <li>where data is either read from or written to the surface</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>Track Skew
    <ul>
      <li>make sure that sequential reads can be properly serviced even when crossing track boundaries</li>
      <li>When the disk needs time to reposition head
        <ul>
          <li>If there is now skew, the head need to wait for next block which requries whole rotation</li>
        </ul>
      </li>
      <li>Outer track has more sectors than inner tracks
        <ul>
          <li>More room geometrically</li>
          <li>Multi-zoned disk drives</li>
          <li>Each zone has same number of sectors</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>Track buffer
    <ul>
      <li>Cache
        <ul>
          <li>Just small amount of the memory</li>
        </ul>
      </li>
      <li>Drive has a choice
        <ul>
          <li>acknowledge
            <ul>
              <li>After put the data in its memory
                <ul>
                  <li>Write back caching</li>
                </ul>
              </li>
              <li>write has actually been written to disk
                <ul>
                  <li>Write through caching</li>
                </ul>
              </li>
            </ul>
          </li>
        </ul>
      </li>
      <li>Dimensional analysis
        <ul>
          <li>RPM</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>I/O time
    <ul>
      <li>Workload
        <ul>
          <li>Random</li>
          <li>Sequential</li>
        </ul>
      </li>
      <li>Capcity and performance
        <ul>
          <li>High performance for searching</li>
          <li>Low capacity</li>
          <li>Low performance on searching</li>
          <li>High capacity</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>Disk Scheduling
    <ul>
      <li>Due to the high cost of I/O</li>
      <li>SSTF: Shortest Seek Time First
        <ul>
          <li>order the queue of I/O request by track
            <ul>
              <li>drive geometry is not available to the host OS
                <ul>
                  <li>Nearest-block-first</li>
                </ul>
              </li>
            </ul>
          </li>
          <li>Starvation</li>
        </ul>
      </li>
      <li>SCAN
        <ul>
          <li>simply moves back and forth across the disk servicing requests in order across the track
            <ul>
              <li>Sweep</li>
            </ul>
          </li>
          <li>F-SCAN
            <ul>
              <li>freezes the queue to be serviced when it is doing a sweep</li>
            </ul>
          </li>
          <li>C-SCAN
            <ul>
              <li>Circular SCAN</li>
              <li>sweeps from outer-to-inner, and then resets at the outer track to begin again</li>
            </ul>
          </li>
          <li>Elevator algorithm → going up and down</li>
        </ul>
      </li>
      <li>Rotation Cost</li>
      <li>shortest positioning time first, SPTF, SATF is the solution</li>
    </ul>
  </li>
  <li>I/O merging
    <ul>
      <li>Merge the request, reordering is performed upon the merged request</li>
    </ul>
  </li>
  <li>Work-conversing
    <ul>
      <li>How long should the system wait before issuing an I/O to disk?
        <ul>
          <li>immediately issue the request to the drive</li>
        </ul>
      </li>
      <li>anticipatory disk scheduling
        <ul>
          <li>non-work-conserving</li>
          <li>waiting for a new and better request results better performance in average</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>]]></content><author><name>JSC</name><email>newwin0198@handong.ac.kr</email></author><category term="OS" /><category term="OS" /><summary type="html"><![CDATA[OS Ch.37]]></summary></entry><entry><title type="html">Operating Systems: Three Easy Pieces Ch. 41</title><link href="http://localhost:4000/recent/Chapter-41/" rel="alternate" type="text/html" title="Operating Systems: Three Easy Pieces Ch. 41" /><published>2023-06-17T00:00:00+09:00</published><updated>2023-06-17T00:00:00+09:00</updated><id>http://localhost:4000/recent/Chapter-41</id><content type="html" xml:base="http://localhost:4000/recent/Chapter-41/"><![CDATA[<p>Locality and the fast file system</p>

<ul>
  <li>Old file system was simple
    <ul>
      <li>The problem: Poor Performance</li>
      <li>UNIX file system treated the disk like it was a random-access memory</li>
      <li>Data was spread all over the place</li>
      <li>the data blocks of a file were often very far away from its inode, thus inducing an expensive seek</li>
      <li>Fragmented</li>
      <li>Degramententation Tool
        <ul>
          <li>minimize the internal fragmentation</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>FFS: Disk Awareness
    <ul>
      <li>Fast File System</li>
      <li>interface
        <ul>
          <li>open, read, write, and close</li>
        </ul>
      </li>
      <li>Cylinder groups
        <ul>
          <li>Single cylinder is a set of tracks on different surfaces of a hard drive</li>
          <li>Block groups</li>
          <li>Consecutive portion of the disk’s address space</li>
          <li>placing two files within the same group</li>
          <li>Super block, ib, db, inode, data block</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>how to allocate
    <ul>
      <li>find the cylinder group with a low number of allocated directories (to balance directories across groups) and a high number of free inodes (to subsequently be able to allocate a bunch of files), and put the directory data and inode in that group</li>
      <li>to allocate the data blocks of a file in the same group as its inode</li>
      <li>it places all files that are in the same directory in the cylinder group of the directory they are in</li>
    </ul>
  </li>
  <li>FFS policies
    <ul>
      <li>the data blocks of each file are near each file’s inode, and files in the same directory are near one another</li>
      <li>common sense</li>
    </ul>
  </li>
  <li>Measuring File Locality
    <ul>
      <li>The random trace was generated by selecting files from within an existing SEER trace in random order and calculating the distance metric between these randomly-ordered accesses</li>
      <li>40% of file accesses were to either the same file or to one in the same director</li>
      <li>a large file would entirely fill the block group it is first placed within</li>
      <li>FFS instead spreads the file spread across groups</li>
      <li>amortization</li>
    </ul>
  </li>
  <li>Internal fragmentation
    <ul>
      <li>internal fragmentation could thus lead to roughly half the disk being wasted for a typical file system</li>
      <li>sub-blocks
        <ul>
          <li>512-byte little blocks that the file system could allocate to files</li>
          <li>the file system will continue allocating 512-byte blocks to it until it acquires a full 4KB of data</li>
        </ul>
      </li>
      <li>A second neat thing that FFS introduced was a disk layout that was optimized for performance</li>
      <li>Parameterization
        <ul>
          <li>How many blocks need to skip to avoid extra rotation</li>
        </ul>
      </li>
      <li>FFS was one of the first file systems to allow for long file names</li>
      <li>symbolic link</li>
    </ul>
  </li>
</ul>]]></content><author><name>JSC</name><email>newwin0198@handong.ac.kr</email></author><category term="OS" /><category term="OS" /><summary type="html"><![CDATA[OS Ch.41]]></summary></entry><entry><title type="html">Operating Systems: Three Easy Pieces Ch. 40</title><link href="http://localhost:4000/recent/Chapter-40/" rel="alternate" type="text/html" title="Operating Systems: Three Easy Pieces Ch. 40" /><published>2023-06-17T00:00:00+09:00</published><updated>2023-06-17T00:00:00+09:00</updated><id>http://localhost:4000/recent/Chapter-40</id><content type="html" xml:base="http://localhost:4000/recent/Chapter-40/"><![CDATA[<p>File System Implementation</p>

<ul>
  <li>Very Simple File System
    <ul>
      <li>The file system is pure software</li>
      <li>we will not be adding hardware features to make some aspect of the file system work better</li>
    </ul>
  </li>
  <li>The first is the data structure of the file system
    <ul>
      <li>data and metadata</li>
      <li>access method → open(), read(), write()</li>
    </ul>
  </li>
  <li>Overall Organization
    <ul>
      <li>Block
        <ul>
          <li>one block size, the common size of 4 KB</li>
          <li>size 4 KB</li>
        </ul>
      </li>
      <li>Data region</li>
      <li>Metadata
        <ul>
          <li>Inode</li>
          <li>Inode table</li>
        </ul>
      </li>
      <li>Allocation structures
        <ul>
          <li>Free list
            <ul>
              <li>points to the next free block</li>
            </ul>
          </li>
          <li>bitmap
            <ul>
              <li>Data region</li>
              <li>Inode</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>Superblock
        <ul>
          <li>Contains information about this particular file system</li>
          <li>inode bitmap</li>
          <li>data bitmap</li>
          <li>Inodes</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>File Organization: The Inode
    <ul>
      <li>inode (short for index node)</li>
      <li>these nodes were originally arranged in an array, and the array indexed into when accessing a particular inode</li>
      <li>Each inode is implicitly referred to by a number (called the i-number), which we’ve earlier called the low-level name of the file</li>
      <li>20KB in size (five 4KB blocks) and thus consisting of 80 inodes (assuming each inode is 256 bytes)</li>
    </ul>
  </li>
  <li>metadata</li>
  <li>direct pointers</li>
  <li>The Multi-Level Index
    <ul>
      <li>Indirect Pointer
        <ul>
          <li>it points to a block that contains more pointers, each of which point to user data</li>
        </ul>
      </li>
      <li>If a file grows large enough, an indirect block is allocated</li>
      <li>the double indirect pointer</li>
      <li>triple is possible</li>
      <li>multi-level index approach to pointing to file blocks. Let’s examine an example with twelve direct pointers and a single and a double indirect block. Assuming a block size of 4 KB, and 4-byte pointers, this structure can accommodate a file of just over 4 GB in size</li>
      <li>Other file systems, including SGI XFS and Linux ext4, use extents instead of simple pointers</li>
      <li>Most files are small</li>
    </ul>
  </li>
  <li>Directory Organization
    <ul>
      <li>each entry has an inode number, record length (the total bytes for the name plus any left over space), string length (the actual length of the name), and finally the name of the entry</li>
      <li>Deleting the file → unlink()</li>
      <li>directory has an inode, somewhere in the inode table</li>
    </ul>
  </li>
  <li>free space management
    <ul>
      <li>pre-allocation policy</li>
      <li>the file system guarantees that a portion of the file will be contiguous on the disk</li>
    </ul>
  </li>
  <li>Access Path
    <ul>
      <li>The file system must traverse the pathname and thus locate the desired inode</li>
      <li>root directory</li>
      <li>i-number of file or directory</li>
      <li>read and lseek
        <ul>
          <li>read in the first block of the file, consulting the inode to find the location of such a block</li>
        </ul>
      </li>
      <li>Close
        <ul>
          <li>No disk I/Os take place</li>
        </ul>
      </li>
      <li>Writing to the file may also allocate a block
        <ul>
          <li>Overwritten</li>
        </ul>
      </li>
      <li>Traffic of reading and writing
        <ul>
          <li>one for inode bitmap, new inode, directory, and directory inode</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>Caching and Buffering
    <ul>
      <li>fixed-size cache</li>
      <li>LRU</li>
      <li>static partioning
        <ul>
          <li>10% of the total memory</li>
        </ul>
      </li>
      <li>Dynamic Partioning
        <ul>
          <li>unified page cache</li>
        </ul>
      </li>
      <li>Write Buffering</li>
      <li>Batch</li>
      <li>Schedule</li>
      <li>Fsync()
        <ul>
          <li>direct I/O interfaces</li>
          <li>raw disk interface</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>]]></content><author><name>JSC</name><email>newwin0198@handong.ac.kr</email></author><category term="OS" /><category term="OS" /><summary type="html"><![CDATA[OS Ch.40]]></summary></entry><entry><title type="html">Operating Systems: Three Easy Pieces Ch. 39</title><link href="http://localhost:4000/recent/Chapter-39/" rel="alternate" type="text/html" title="Operating Systems: Three Easy Pieces Ch. 39" /><published>2023-06-17T00:00:00+09:00</published><updated>2023-06-17T00:00:00+09:00</updated><id>http://localhost:4000/recent/Chapter-39</id><content type="html" xml:base="http://localhost:4000/recent/Chapter-39/"><![CDATA[<p>File and Directories</p>

<ul>
  <li>Persistence Storage
    <ul>
      <li>HDD</li>
      <li>SSD</li>
    </ul>
  </li>
  <li>Files and Directories
    <ul>
      <li>inode number</li>
      <li>directory
        <ul>
          <li>Directory tree (hierarchy)</li>
          <li>Root directory</li>
          <li>Subdirectory</li>
          <li>Separator</li>
        </ul>
      </li>
      <li>Type of the file</li>
    </ul>
  </li>
  <li>Creating file
    <ul>
      <li>open()</li>
      <li>file descriptor
        <ul>
          <li>Capability</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>Reading and Writing files
    <ul>
      <li>Strace
        <ul>
          <li>trace the system calls made by a program</li>
          <li>Flags</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>Not sequential reading and writing
    <ul>
      <li>random offset
        <ul>
          <li>searching specific word</li>
        </ul>
      </li>
      <li>File Offset</li>
      <li>Open file table
        <ul>
          <li>OS can use this to determine whether the opened file is readable or writable (or both), which underlying file it refers to (as pointed to by the struct inode pointer ip), and the current offset (off).</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>Shared File Table Entities
    <ul>
      <li>Fork and dup</li>
      <li>reference count</li>
      <li>The dup() call allows a process to create a new file descriptor that refers to the same underlying open file as an existing descriptor</li>
    </ul>
  </li>
  <li>Fsync()
    <ul>
      <li>(DBMS), development of a correct recovery protocol requires the ability to force writes to disk from time to time</li>
    </ul>
  </li>
  <li>Renaming files
    <ul>
      <li>rename() call is atomic</li>
    </ul>
  </li>
  <li>Information about files
    <ul>
      <li>metadata
        <ul>
          <li>stat() or fstat() system calls</li>
        </ul>
      </li>
      <li>inode</li>
    </ul>
  </li>
</ul>

<p><img src="Chapter%2039%206ddb996a8e204d40b66eacace1a2cff9/Untitled.png" alt="Untitled" /></p>

<ul>
  <li>Removing Files
    <ul>
      <li>unlink() ?</li>
    </ul>
  </li>
  <li>Making Directories
    <ul>
      <li>To create a directory, a single system call, mkdir(), is available. The eponymous mkdir program can be used to create such a directory.</li>
    </ul>
  </li>
  <li>Reading Directories
    <ul>
      <li>the program uses three calls, opendir(), readdir(), and closedir()</li>
      <li>struct dirent</li>
    </ul>
  </li>
  <li>Deleting Directories
    <ul>
      <li>rmdir()</li>
    </ul>
  </li>
  <li>Hard Links
    <ul>
      <li>he link() system call takes two arguments, an old pathname and a new one; when you “link” a new file name to an old one, you essentially create another way to refer to the same file</li>
      <li>The way link() works is that it simply creates another name in the directory you are creating the link to</li>
      <li>reference count (link count)</li>
    </ul>
  </li>
  <li>Symbolic Links
    <ul>
      <li>Soft Link</li>
      <li>the original file can now be accessed through the file name file as well as the symbolic link name file2.</li>
      <li>dangling reference possibility</li>
    </ul>
  </li>
  <li>Permission Bits And Access Control Lists
    <ul>
      <li>permission bits</li>
      <li>what the owner of the file can do to it, what someone in a group can do to the file, and finally, what anyone (sometimes referred to as other) can do.</li>
      <li>chmod command</li>
      <li>form of an access control list (ACL) per directory</li>
    </ul>
  </li>
  <li>Making And Mounting A File System
    <ul>
      <li>What mount does, quite simply is take an existing directory as a target mount point and essentially paste a new file system onto the directory tree at that point</li>
      <li>mkfs</li>
    </ul>
  </li>
</ul>]]></content><author><name>JSC</name><email>newwin0198@handong.ac.kr</email></author><category term="OS" /><category term="OS" /><summary type="html"><![CDATA[OS Ch.39]]></summary></entry><entry><title type="html">Operating Systems: Three Easy Pieces Ch. 36</title><link href="http://localhost:4000/recent/Chapter-36/" rel="alternate" type="text/html" title="Operating Systems: Three Easy Pieces Ch. 36" /><published>2023-06-12T00:00:00+09:00</published><updated>2023-06-12T00:00:00+09:00</updated><id>http://localhost:4000/recent/Chapter-36</id><content type="html" xml:base="http://localhost:4000/recent/Chapter-36/"><![CDATA[<p>Input/output device (I/O)</p>

<ul>
  <li>System Architecture
    <ul>
      <li>Hierarchiacal structure
        <ul>
          <li>CPU, memory, memory BUS</li>
          <li>I/O bus
            <ul>
              <li>PCI
                <ul>
                  <li>Peripheral Component Interconnect</li>
                  <li>High-speed I/O devices such as graphics</li>
                </ul>
              </li>
              <li>Peripheral bus
                <ul>
                  <li>Lower speed bus</li>
                  <li>SATA, USB</li>
                  <li>connects to disks, mice, keyboards</li>
                </ul>
              </li>
            </ul>
          </li>
          <li>Reasons
            <ul>
              <li>Physics, cost</li>
              <li>a high-performance memory bus does not have much room to plug devices and such into it</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>Modern Computer system
        <ul>
          <li>DMI
            <ul>
              <li>Direct Media Interface</li>
              <li>Devices connect to the chip</li>
            </ul>
          </li>
          <li>ATA → The AT Attachment
            <ul>
              <li>SATA, eSATA</li>
            </ul>
          </li>
          <li>USB
            <ul>
              <li>Universal Serial Bus → Keyborads, Mice</li>
            </ul>
          </li>
          <li>PCIe
            <ul>
              <li>Peripheral Component Interconnect Express</li>
              <li>Higher performance → networ, NVMe(High speed)</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>Canonical Device
        <ul>
          <li>Hardware interface
            <ul>
              <li>present interface that allows the system software to control its operation</li>
              <li>All device have specified interface and protocol</li>
            </ul>
          </li>
          <li>Internal structure
            <ul>
              <li>specific and responsible for implementin the abstraction the devide presents to the system
                <ul>
                  <li>Simple device such as CPU, memroy, RAID controller</li>
                </ul>
              </li>
              <li>thousands of line of firmware</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>Canonical Protocol
        <ul>
          <li>Status register → current status</li>
          <li>Command register → to perform certain task</li>
          <li>Data register → pass data to device</li>
          <li>Four steps
            <ul>
              <li>Pooling, waiting for the device is ready to receive a command</li>
              <li>Sending data
                <ul>
                  <li>Programmed I/O</li>
                </ul>
              </li>
              <li>Command using command register</li>
              <li>OS waits for device poerform the task</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>Lowering CPU overhead
        <ul>
          <li>interrupt
            <ul>
              <li>Instead of pooling</li>
              <li>Interrupt Service Routine
                <ul>
                  <li>Interrupt Handler</li>
                </ul>
              </li>
              <li>Allows overlap of computation and I/O</li>
            </ul>
          </li>
          <li>using interrupts is not always the best solution
            <ul>
              <li>Interrupt is expensive, inefficient in the case of simple I/O interrupt
                <ul>
                  <li>Hybrid, two-phased approach</li>
                  <li>First Poll</li>
                  <li>After certain time, interrupt</li>
                  <li>if a device is fast, it may be best to poll; if it is slow, interrupt</li>
                </ul>
              </li>
              <li>coalescing
                <ul>
                  <li>device need to raise an interrupt first waits for a bit</li>
                  <li>multiple interrupts can be coalesced into a single interrupt delivery</li>
                </ul>
              </li>
            </ul>
          </li>
        </ul>
      </li>
      <li>More Efficient Data Movement With DMA
        <ul>
          <li>when using programmed I/O (PIO) to transfer a large chunk of data to a device, the CPU is once again over burdened with a rather trivial task
            <ul>
              <li>Copying the data using CPU → trivial task</li>
            </ul>
          </li>
          <li>Direct Memory Access (DMA)
            <ul>
              <li>OS program DMA engine by telling it where the data lives in memory, how much data to copy, and which device to send it to.</li>
              <li>DMA is complete → raise the interrupt, and the OS knows the transfer control is completed</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>Methods Of Device Interaction
        <ul>
          <li>explicit I/O instructions
            <ul>
              <li>previleged instructions</li>
              <li>OS controls device, directly communicate with the device</li>
            </ul>
          </li>
          <li>Memory mapped I/O
            <ul>
              <li>the hardware makes device registers available as if they were memory locations</li>
              <li>OS issues a load (to read) or store (to write) the address</li>
              <li>The memory-mapped approach is nice in that no new instructions are needed to support it</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>Device Driver
        <ul>
          <li>how to fit devices, each of which have very specific interfaces</li>
          <li>OS must know in detail how a device work
            <ul>
              <li>Device Driver solve the question</li>
            </ul>
          </li>
        </ul>

        <p><img src="Chapter%2036%2061b718fbd8bf4b238b94fd0431a9941a/Untitled.png" alt="Untitled" /></p>

        <ul>
          <li>70% of OS code is found in device drivers</li>
          <li>Window is high as well</li>
        </ul>
      </li>
      <li>An IDE disk presents a simple interface to the system, consisting of four types of register: control, command block, status, and error
        <ul>
          <li>Basic Protocol
            <ul>
              <li>Wait for ready</li>
              <li>Write parameter to command register</li>
              <li>Start I/O</li>
              <li>Data transfer</li>
              <li>Handle interrupts</li>
              <li>Error Handling</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>Who started first?
        <ul>
          <li>Not clear</li>
          <li>people built these early machines, it became obvious that I/O support was needed.</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>]]></content><author><name>JSC</name><email>newwin0198@handong.ac.kr</email></author><category term="OS" /><category term="OS" /><summary type="html"><![CDATA[OS Ch.36]]></summary></entry><entry><title type="html">Operating Systems: Three Easy Pieces Ch. 31</title><link href="http://localhost:4000/recent/Chapter-31/" rel="alternate" type="text/html" title="Operating Systems: Three Easy Pieces Ch. 31" /><published>2023-06-12T00:00:00+09:00</published><updated>2023-06-12T00:00:00+09:00</updated><id>http://localhost:4000/recent/Chapter-31</id><content type="html" xml:base="http://localhost:4000/recent/Chapter-31/"><![CDATA[<p>Semaphores</p>

<ul>
  <li>both locks and condition variables to solve a broad range of relevant and interesting concurrency problems</li>
  <li>POSIX standard
    <ul>
      <li>sem_wait()</li>
      <li>sem_post()</li>
      <li>sem_init()
        <ul>
          <li>Second argument → 0: it will be shared between threads on same process</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>Binary Semaphores
    <ul>
      <li>it will wait only if the value is not greater than or equal to 0</li>
      <li>scheduler state
        <ul>
          <li>Run</li>
          <li>Ready</li>
          <li>Sleep</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>Semaphores for ordering
    <ul>
      <li>Ordering primitives</li>
      <li>the parent will call sem wait() before the child has called sem post(); we’d like the parent to wait for the child to run.
        <ul>
          <li>Only when the initial value is 0 is possible</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>Producer/Consumer Problem
    <ul>
      <li>Need to add mutual exclusion
        <ul>
          <li>using two locks</li>
          <li>There is a simple cycle here. The consumer holds the mutex and is waiting for the someone to signal full. The producer could signal full but is waiting for the mutex. Thus, the producer and consumer are each stuck waiting for each other: a classic deadlock.</li>
        </ul>
      </li>
      <li>Avoiding Deadlock
        <ul>
          <li>we simply must reduce the scope of the lock</li>
          <li>using two locks in specific sequences</li>
        </ul>
      </li>
      <li>Sometimes, bound buffer</li>
    </ul>
  </li>
  <li>Reader-Writer Locks
    <ul>
      <li>The code is pretty simple. If some thread wants to update the data structure in question, it should call the new pair of synchronization operations</li>
      <li>when the first reader acquires the lock; in that case, the reader also acquires the write lock</li>
      <li>once a reader has acquired a read lock, more readers will be allowed to acquire the read lock too</li>
    </ul>

    <p><a href="https://m.blog.naver.com/hirit808/221786966867">KOCW 운영체제 7: 독자 저자 문제(Readers-Writers Problem)</a></p>
  </li>
  <li>dining philosopher’s problem
    <ul>
      <li>each has times where they think and don’t need any forks, and times when they eat a philosopher needs two forks, both the one on their left and the one on their right</li>
      <li>deadlock. If each philosopher happens to grab the fork on their left before any philosopher can grab the fork on their right, each will be stuck holding one fork and waiting for another</li>
      <li>Breaking The Dependency
        <ul>
          <li>gets the forks in a different order than the others; the put forks() code remains the same</li>
          <li>cigarette smoker’s problem or the sleeping barber problem</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p><a href="https://dkswnkk.tistory.com/412">[OS] 식사하는 철학자들 문제(The Dining-Philosophers Problem)</a></p>

<ul>
  <li>Thread Throttling
    <ul>
      <li>A simple semaphore can solve this problem. By initializing the value of the semaphore to the maximum number of threads you wish to enter the memory-intensive region at once, and then putting a sem wait() and sem post() around the region, a semaphore can naturally throttle the number of threads that are ever concurrently in the dangerous region of the code</li>
    </ul>
  </li>
  <li>Zemaphores</li>
</ul>]]></content><author><name>JSC</name><email>newwin0198@handong.ac.kr</email></author><category term="OS" /><category term="OS" /><summary type="html"><![CDATA[OS Ch.31]]></summary></entry></feed>